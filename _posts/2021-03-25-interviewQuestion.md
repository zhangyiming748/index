---
layout:     post                    # 使用的布局(不需要改)
title:     Go方向面试题            # 标题
subtitle:   我是一只被禁足的安小鸟 #副标题
date:       2021-03-25  00:01:02 GMT+0800             # 时间
author:     Zen                 # 作者
header-img: img/photo/birdAngle.webp    #这篇文章标题背景图片
catalog: True                # 是否归档
tags:                               #标签
    - 网络原理
---

# 字节跳动

|Q|A|
|:---|:---:|
|go channel close后读的问题|如果有缓冲,关闭channel后缓冲可读出,不可再向通道中写入,否则panic: send on closed channel｜
|Linux grep命令查找日志文件相关内容|`grep [-abcEFGhHilLnqrsvVwxy][-A<显示行数>][-B<显示列数>][-C<显示列数>][-d<进行动作>][-e<范本样式>][-f<范本文件>][--help][范本样式][文件或目录...]`|
|B+树结构|是一个N叉排序树,每个节点通常有多个孩子,一棵B+树包含根节点\内部节点和叶子节点|
|为什么用B+树|数据只存在叶子结点,并且叶子结点中的数据组成链表,每个数据都保存着下一个元素的位置,便于范围查找|
|io多路复用|通过一种机制,一个进程可以监视多个描述符,一旦某个描述符就绪(一般是读就绪或者写就绪),能够通知程序进行相应的读写操作.但select,pselect,poll,epoll本质上都是同步I/O|
|epoll和select的区别|epoll使用一个文件描述符管理多个描述符,将用户关系的文件描述符的事件存放到内核的一个事件表中,这样在用户空间和内核空间的copy只需一次<br>调用后select函数会阻塞,直到有描述符就绪(有数据 可读\可写\或者有except),或者超时(timeout指定等待时间,如果立即返回设为null即可),函数返回.当select函数返回后,可以通过遍历fdset,来找到就绪的描述符.轮询方法效率较低<br>select:单个进程所能打开的最大连接数有FD SETSIZE宏定义,其大小是32个整数的大小(在32位的机器上,大小就是32x32,同理64位机器上FD SETSIZE为32*64),当然我们可以对进行修改,然后重新编译内核,但是性能可能会受到影响,这需要进一步的测试<br>poll:poll本质上和select没有区别,但是它没有大连接数的限制,原因是它是基于链表来存储的<br>epoll:虽然连接数有上限,但是很大,1G内存的机器上可以打开10万左右的连接,2G内存的机器可以打开20万左右的连接<br>select:因为每次调用时都会对连接进行线性遍历,所以随着FD的增加会造成遍历速度慢的"线性下降性能问题"<br>poll:同上<br>epoll:因为epoll内核中实现是根据每个fd上的Callback函数来实现的,只有活跃的socket才会主动调用callback,所以在活跃socket较少的情况下,使用epoll没有前面两者的线性下降的性能问题,但是所有socket都很活跃的情况下,可能会有性能问题<br>select:内核需要将消息传递到用户空间,都需要内核拷贝动作<br>poll:同上<br>epoll:epoll通过内核和用户空间共享一块内存来实现的|
|计网七层协议|应用层->表示层->会话层->传输层>网络层>数据链路层>物理层|
|线程进程区别|根本区别:进程是操作系统资源分配的基本单位,而线程是处理器任务调度和执行的基本单位<br>资源开销:每个进程都有独立的代码和数据空间(程序上下文),程序之间的切换会有较大的开销;线程可以看做轻量级的进程,同一类线程共享代码和数据空间,每个线程都有自己独立的运行栈和程序计数器(PC),线程之间切换的开销小<br>包含关系:如果一个进程内有多个线程,则执行过程不是一条线的,而是多条线(线程)共同完成的;线程是进程的一部分所以线程也被称为轻权进程或者轻量级进程<br>内存分配:同一进程的线程共享本进程的地址空间和资源,而进程之间的地址空间和资源是相互独立的<br>影响关系:一个进程崩溃后,在保护模式下不会对其他进程产生影响,但是一个线程崩溃整个进程都死掉.所以多进程要比多线程健壮<br>执行过程:每个独立的进程有程序运行的入口\顺序执行序列和程序出口.但是线程不能独立执行,必须依存在应用程序中,由应用程序提供多个线程执行控制,两者均可并发执行|
|线程怎么调度|有两种调度模型:分时调度模型和抢占式调度模型<br>分时调度模型是指让所有的线程轮流获得cpu的使用权,并且平均分配每个线程占用的CPU的时间片<br>java虚拟机采用抢占式调度模型,是指优先让可运行池中优先级高的线程占用CPU,如果可运行池中的线程优先级相同,那么就随机选择一个线程,使其占用CPU.处于运行状态的线程会一直运行,直至它不得不放弃CPU<br>放弃CPU原因:java虚拟机让当前线程暂时放弃CPU,转到就绪状态,使其它线程获得运行机会<br>当前线程因为某些原因而进入阻塞状态<br>线程结束运行|
|进程通信|[超链接](https://zhangyiming748.github.io/2021/03/25/Inter-process-communication)|
|TCP可靠连接|[超链接](https://zhangyiming748.github.io/2021/03/25/TCP/)|
|go slice 和 array 区别|[超链接](https://zhangyiming748.github.io/2021/03/25/sliceVSarray/)|
|GMP 模型||
|分布式缓存框架,singleflight 并发,深挖,一直挖到sync.WaitGroup ||
|缓存击穿&缓存雪崩|缓存击穿指的是某个查询在缓存中没有找到，需要去数据库中查询<br>缓存穿透指的是缓存穿透是指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞<br>缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。|
|sync.WaitGroup|常用的有Add\Done\Wait,函数间传递需要传指针|
|cookiesession||
|设计学生成绩数据库,并写出查询语文成绩top3的人.url输入全过程.从此引出后端除了响应请求还有什么||
|什么是分布式系统||
|由上面分布式系统引出负载均衡||
|负载均衡算法有哪些||
|一致性哈希算法深挖.一致性哈希与普通哈希的区别||
|手撕代码LRU||
|手撕代码生产者消费者模型||
|手撕代码反转连表||
|算法题:三数之和|[代码](https://raw.githubusercontent.com/zhangyiming748/zhangyiming748.github.io/master/code/threeSum.go)|
|session如何存储||
|多台服务器session存储怎么设计||
|除了存redis还能怎么存||
|http和https区别||
|https详细过程||
|getpost区别.还有什么其他方法.分别说说是做什么的||
|web安全问题||
|设计一个短链接服务.如何抗住大qps,抗大流量.url哈希函数怎么设计(怎么存,怎么统计qps)||

# 腾讯

|Q|A|
|:---:|:---:|
|tcp和udp的特性,tcp三次握手\四次挥手||
|http2.0了解吗?和http1.1的差距?||
|反爬了解吗?反爬的几项技术在项目里面怎么实现的?||
|项目部署的服务器是单机的,请问如果是大流量高并发请求服务器怎么处理?||
|数据结构:常用排序算法,快排\堆排的原理和实现.||
|算法:topK,时间复杂度||
|如果是亿级数据怎么处理?||
|b树 b+树区别||
|tcp 可靠性,然后问十六位校验和怎么实现的||
|TCP 粘包||
|进程 协程 线程 ||
|跳表怎么实现||
|go的调度||
|go struct能不能比较?||
|go defer(for defer)||
|select可以用于什么?||
|context包的用途?||
|client如何实现长连接?||
|主协程如何等其余协程完再操作||
|slice,len,cap,共享,扩容||
|map如何顺序读取?||
|实现set||
|实现消息队列(多生产者,多消费者)||
|大文件排序||
|基本排序,哪些是稳定的||
|http get跟head||
|http 401,403||
|http keep-alive||
|http能不能一次连接多次请求,不等后端返回||
|tcp与udp区别,udp优点,适用场景||
|time-wait的作用||
|数据库如何建索引||
|孤儿进程,僵尸进程||
|死锁条件,如何避免||
|linux命令,查看端口占用,cpu负载,内存占用,如何发送信号给一个进程||
|git文件版本,使用顺序,merge跟rebase||
|项目实现爬虫的流程||
|爬虫如何做的鉴权吗?||
|怎么实现的分布式爬虫||
|电商系统图片多会造成带宽过高,如何解决?||
|micro服务发现||
|mysql底层有哪几种实现方式||
|channel底层实现||
|java nio和go 区别||
|读写锁底层是怎么实现的?||
|go-micro 微服务架构怎么实现水平部署的,代码怎么实现?||
|micro怎么用||
|怎么做服务发现的||
|mysql索引为什么要用B+树?||
|mysql语句性能评测?||
|服务发现有哪些机制||
|raft算法是那种一致性算法||
|raft有什么特点||
|当go服务部署到线上了,发现有内存泄露,该怎么处理||
|https 握手,为什么需要 非对称加密 和 对称加密||

# 金山

|Q|A|
|:---:|:---:|
|PHP-FPM||
|CGI 是一个 Web Server 与 CGI 程序之间进行数据传输的协议,保证传递的是标准数据||
|PHP-CGI 是 PHP 解析器(CGI 程序) ||
|FastCGI 是用来提高 CGI 程序性能的方案/协议.FastCGI 会先启动一个 master,解析配置文件,初始化执行环境,然后再启动多个 worker.当请求过来时,master 会传递给一个 worker,然后立即可以接收下一个请求,避免重复劳动,提高效率 ||
|PHP-FPM 是实现 FastCGI 的程序 ||
|PHP 和 Go 对比 ||
|MVC 模式 ||
|MySQL 优化(索引\分表分库) ||
|浏览器地址栏输入网址整个过程 ||
|TCP 三次握手和四次挥手 ||
|Linux 相关(介绍了一下基本操作命令) ||
|Docker 相关 ||
|Git 相关 ||
|开发环境(Windows\Linux) ||
|CI / CD 发布流程 ||
|HTTP 长连接(HTTP 1.1 版本)||

# 腾讯音乐

|Q|A|
|:---:|:---:|
|TCP 拥塞控制(快速恢复\快速重传)||
|从面向连接的特性回答||
|UDP 实现可靠连接,从 TCP 可靠连接特性回答||
|MySQL 索引数据结构||
|索引为什么使用 B+ 树||
|为什么不使用 Hash 结构||
|like 模糊查询 ||
|范围查询 ||
|结合事务隔离级别||
|slice 和 array 区别||
|向为 nil 的 channel 发送数据会怎么样||
|map 取一个 key,然后修改这个值,原 map 数据的值会不会变化||
|根据 map 存储的类型回答||
|for 循环遍历 slice 有什么问题||
|Go 闭包||
|进程\线程\协程区别||
|输入 URL 发生的整个网络过程 ||
|Redis 怎么保证数据一致性 ||
|TCP 流量控制\拥塞控制 ||
|TCP 半连接队列 ||
|TCP 半关闭状态 ||
|TCP TIME_WAIT 状态 ||
|内核态\用户态 ||
|Hash 实现\冲突解决\应用 ||
|快速排序||
|堆排序||
|大小堆 ||
|100 枚硬币,其中有一枚硬币重量不一样,用天平秤怎么快速找到这一枚硬币||

# 跟谁学

|Q|A|
|:---:|:---:|
|说一下Redis中HashMap的实现(双table,渐进式rehash,扩容条件,缩容条件,bgsave,CopyOnWrite机制) ||
|扩容过程中有新的请求流程||
|Redis其他的数据结构(SDS,RAW,INTSET,ZIPLIST,SKIPLIST,QUICKLIST) ||
|跳表的实现?||
|Redis的定时任务怎么实现的?||
|订单服务过期是怎么设计的(RabbitMQ死信队列)||

# 百度

|Q|A|
|:---:|:---:|
|数据库问题,给你10个数据库服务器,每个只能接500的qps,现在要实现4000qps,要怎么做?说用负载均衡,使用binlog保证10个服务器的数据一致性 ||
|如果有读有写,如何实现高并发,数据库读写分离 ||
|对于两个写库,两个请求向分别打到两个写库中,他们互相向对方同步,会不会出现不一致,||
|哈希的实现有哪几种,如何取hashcode,冲突检测几种方法 ||
|用过go,那么进程,协程,线程各自的优缺点 ||
|算法题:遍历二叉树,循环有序数组找指定值 |[![遍历二叉树](https://z3.ax1x.com/2021/03/25/6O7QjH.png)](https://raw.githubusercontent.com/zhangyiming748/zhangyiming748.github.io/master/code/traverse_the_binary_tree.go)|
|事务是怎么实现的?(undo_log,MVCC) ||
|mongodb和redis的区别||
|请你说说golang的CSP思想||
|go 内存逃逸分析(分析了栈帧,讲五种例子,描述堆栈优缺点,点头)||
|是否有逃逸分析过||
|defer recover 的问题||
|mysql 索引慢分析(线上开启slowlog,提取慢查询,然后仔细分析explain 中 tye字段以及extra字段,发生的具体场景及mysql是怎么做的||
