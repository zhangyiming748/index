---
layout:     post                    # 使用的布局(不需要改)
title:     Go方向面试题            # 标题
subtitle:   我是一只被禁足的安小鸟 #副标题
date:       2021-03-25  00:01:02 GMT+0800             # 时间
author:     Zen                 # 作者
header-img: img/photo/birdAngle.webp    #这篇文章标题背景图片
catalog: True                # 是否归档
tags:                               #标签
    - 网络原理
---

# 字节跳动

|Q|A|
|:---|:---:|
|go channel close后读的问题|如果有缓冲,关闭channel后缓冲可读出,不可再向通道中写入,否则panic: send on closed channel｜
|Linux grep命令查找日志文件相关内容|`grep [-abcEFGhHilLnqrsvVwxy][-A<显示行数>][-B<显示列数>][-C<显示列数>][-d<进行动作>][-e<范本样式>][-f<范本文件>][--help][范本样式][文件或目录...]`|
|B+树结构|是一个N叉排序树,每个节点通常有多个孩子,一棵B+树包含根节点\内部节点和叶子节点|
|为什么用B+树|数据只存在叶子结点,并且叶子结点中的数据组成链表,每个数据都保存着下一个元素的位置,便于范围查找|
|io多路复用|通过一种机制,一个进程可以监视多个描述符,一旦某个描述符就绪(一般是读就绪或者写就绪),能够通知程序进行相应的读写操作.但select,pselect,poll,epoll本质上都是同步I/O|
|epoll和select的区别|epoll使用一个文件描述符管理多个描述符,将用户关系的文件描述符的事件存放到内核的一个事件表中,这样在用户空间和内核空间的copy只需一次<br>调用后select函数会阻塞,直到有描述符就绪(有数据 可读\可写\或者有except),或者超时(timeout指定等待时间,如果立即返回设为null即可),函数返回.当select函数返回后,可以通过遍历fdset,来找到就绪的描述符.轮询方法效率较低<br>select:单个进程所能打开的最大连接数有FD SETSIZE宏定义,其大小是32个整数的大小(在32位的机器上,大小就是32x32,同理64位机器上FD SETSIZE为32*64),当然我们可以对进行修改,然后重新编译内核,但是性能可能会受到影响,这需要进一步的测试<br>poll:poll本质上和select没有区别,但是它没有大连接数的限制,原因是它是基于链表来存储的<br>epoll:虽然连接数有上限,但是很大,1G内存的机器上可以打开10万左右的连接,2G内存的机器可以打开20万左右的连接<br>select:因为每次调用时都会对连接进行线性遍历,所以随着FD的增加会造成遍历速度慢的"线性下降性能问题"<br>poll:同上<br>epoll:因为epoll内核中实现是根据每个fd上的Callback函数来实现的,只有活跃的socket才会主动调用callback,所以在活跃socket较少的情况下,使用epoll没有前面两者的线性下降的性能问题,但是所有socket都很活跃的情况下,可能会有性能问题<br>select:内核需要将消息传递到用户空间,都需要内核拷贝动作<br>poll:同上<br>epoll:epoll通过内核和用户空间共享一块内存来实现的|
|计网七层协议|应用层->表示层->会话层->传输层>网络层>数据链路层>物理层|
|线程进程区别|根本区别:进程是操作系统资源分配的基本单位,而线程是处理器任务调度和执行的基本单位<br>资源开销:每个进程都有独立的代码和数据空间(程序上下文),程序之间的切换会有较大的开销;线程可以看做轻量级的进程,同一类线程共享代码和数据空间,每个线程都有自己独立的运行栈和程序计数器(PC),线程之间切换的开销小<br>包含关系:如果一个进程内有多个线程,则执行过程不是一条线的,而是多条线(线程)共同完成的;线程是进程的一部分所以线程也被称为轻权进程或者轻量级进程<br>内存分配:同一进程的线程共享本进程的地址空间和资源,而进程之间的地址空间和资源是相互独立的<br>影响关系:一个进程崩溃后,在保护模式下不会对其他进程产生影响,但是一个线程崩溃整个进程都死掉.所以多进程要比多线程健壮<br>执行过程:每个独立的进程有程序运行的入口\顺序执行序列和程序出口.但是线程不能独立执行,必须依存在应用程序中,由应用程序提供多个线程执行控制,两者均可并发执行|
|线程怎么调度|有两种调度模型:分时调度模型和抢占式调度模型<br>分时调度模型是指让所有的线程轮流获得cpu的使用权,并且平均分配每个线程占用的CPU的时间片<br>java虚拟机采用抢占式调度模型,是指优先让可运行池中优先级高的线程占用CPU,如果可运行池中的线程优先级相同,那么就随机选择一个线程,使其占用CPU.处于运行状态的线程会一直运行,直至它不得不放弃CPU<br>放弃CPU原因:java虚拟机让当前线程暂时放弃CPU,转到就绪状态,使其它线程获得运行机会<br>当前线程因为某些原因而进入阻塞状态<br>线程结束运行|
|进程通信|[超链接](https://zhangyiming748.github.io/2021/03/25/Inter-process-communication)|
|TCP可靠连接|[超链接](https://zhangyiming748.github.io/2021/03/25/TCP/)|
|go slice 和 array 区别|[超链接](https://zhangyiming748.github.io/2021/03/25/sliceVSarray/)|
|GMP 模型||
|分布式缓存框架,singleflight 并发,深挖,一直挖到sync.WaitGroup ||
|缓存击穿&缓存雪崩|缓存击穿指的是某个查询在缓存中没有找到,需要去数据库中查询<br>缓存穿透指的是缓存穿透是指查询一个一定不存在的数据,由于缓存是不命中时被动写的,并且出于容错考虑,如果从存储层查不到数据则不写入缓存,这将导致这个不存在的数据每次请求都要到存储层去查询,失去了缓存的意义.在流量大时,可能DB就挂掉了,要是有人利用不存在的key频繁攻击我们的应用,这就是漏洞<br>缓存雪崩是指在我们设置缓存时采用了相同的过期时间,导致缓存在某一时刻同时失效,请求全部转发到DB,DB瞬时压力过重雪崩.|
|sync.WaitGroup|常用的有Add\Done\Wait,函数间传递需要传指针|
|cookiesession||
|设计学生成绩数据库,并写出查询语文成绩top3的人.url输入全过程.从此引出后端除了响应请求还有什么||
|什么是分布式系统||
|由上面分布式系统引出负载均衡||
|负载均衡算法有哪些||
|一致性哈希算法深挖.一致性哈希与普通哈希的区别||
|手撕代码LRU||
|手撕代码生产者消费者模型||
|手撕代码反转连表||
|算法题:三数之和|[代码](https://raw.githubusercontent.com/zhangyiming748/zhangyiming748.github.io/master/code/threeSum.go)|
|session如何存储||
|多台服务器session存储怎么设计||
|除了存redis还能怎么存||
|http和https区别|明文传输，安全协议等|
|https详细过程||
|getpost区别.还有什么其他方法.分别说说是做什么的||
|web安全问题||
|设计一个短链接服务.如何抗住大qps,抗大流量.url哈希函数怎么设计(怎么存,怎么统计qps)||

# 腾讯

|Q|A|
|:---:|:---:|
|tcp和udp的特性,tcp三次握手\四次挥手|可靠连接|
|http2.0了解吗?和http1.1的差距?||
|反爬了解吗?反爬的几项技术在项目里面怎么实现的?||
|项目部署的服务器是单机的,请问如果是大流量高并发请求服务器怎么处理?||
|数据结构:常用排序算法,快排\堆排的原理和实现.||
|算法:topK,时间复杂度||
|如果是亿级数据怎么处理?||
|b树 b+树区别||
|tcp 可靠性,然后问十六位校验和怎么实现的||
|TCP 粘包||
|进程 协程 线程 ||
|跳表怎么实现||
|go的调度||
|go struct能不能比较?|某些情况下可以|
|go defer(for defer)||
|select可以用于什么?|控制最大并发，实现超时判断|
|context包的用途?||
|client如何实现长连接?||
|主协程如何等其余协程完再操作|wait.group|
|slice,len,cap,共享,扩容||
|map如何顺序读取?||
|实现set||
|实现消息队列(多生产者,多消费者)||
|大文件排序||
|基本排序,哪些是稳定的||
|http get跟head||
|http 401,403||
|http keep-alive||
|http能不能一次连接多次请求,不等后端返回||
|tcp与udp区别,udp优点,适用场景|可靠连接和不可靠连接,udp适合在对数据完整性不强制要求的场景下使用,如网络电话|
|time-wait的作用||
|数据库如何建索引||
|孤儿进程,僵尸进程||
|死锁条件,如何避免||
|linux命令,查看端口占用,cpu负载,内存占用,如何发送信号给一个进程||
|git文件版本,使用顺序,merge跟rebase||
|项目实现爬虫的流程||
|爬虫如何做的鉴权吗?||
|怎么实现的分布式爬虫||
|电商系统图片多会造成带宽过高,如何解决?||
|micro服务发现||
|mysql底层有哪几种实现方式||
|channel底层实现||
|java nio和go 区别||
|读写锁底层是怎么实现的?||
|go-micro 微服务架构怎么实现水平部署的,代码怎么实现?||
|micro怎么用||
|怎么做服务发现的||
|mysql索引为什么要用B+树?||
|mysql语句性能评测?||
|服务发现有哪些机制||
|raft算法是那种一致性算法||
|raft有什么特点||
|当go服务部署到线上了,发现有内存泄露,该怎么处理||
|https 握手,为什么需要 非对称加密 和 对称加密||

# 金山

|Q|A|
|:---:|:---:|
|PHP-FPM||
|CGI 是一个 Web Server 与 CGI 程序之间进行数据传输的协议,保证传递的是标准数据||
|PHP-CGI 是 PHP 解析器(CGI 程序) ||
|FastCGI 是用来提高 CGI 程序性能的方案/协议.FastCGI 会先启动一个 master,解析配置文件,初始化执行环境,然后再启动多个 worker.当请求过来时,master 会传递给一个 worker,然后立即可以接收下一个请求,避免重复劳动,提高效率 ||
|PHP-FPM 是实现 FastCGI 的程序 ||
|PHP 和 Go 对比 ||
|MVC 模式 ||
|MySQL 优化(索引\分表分库) ||
|浏览器地址栏输入网址整个过程 ||
|TCP 三次握手和四次挥手 ||
|Linux 相关(介绍了一下基本操作命令) ||
|Docker 相关 ||
|Git 相关 ||
|开发环境(Windows\Linux) ||
|CI / CD 发布流程 ||
|HTTP 长连接(HTTP 1.1 版本)||

# 腾讯音乐

|Q|A|
|:---:|:---:|
|TCP 拥塞控制(快速恢复\快速重传)||
|从面向连接的特性回答||
|UDP 实现可靠连接,从 TCP 可靠连接特性回答||
|MySQL 索引数据结构||
|索引为什么使用 B+ 树||
|为什么不使用 Hash 结构|无法实现范围查找|
|like 模糊查询 ||
|范围查询 ||
|结合事务隔离级别||
|slice 和 array 区别||
|向为 nil 的 channel 发送数据会怎么样||
|map 取一个 key,然后修改这个值,原 map 数据的值会不会变化||
|根据 map 存储的类型回答||
|for 循环遍历 slice 有什么问题||
|Go 闭包||
|进程\线程\协程区别||
|输入 URL 发生的整个网络过程 ||
|Redis 怎么保证数据一致性 ||
|TCP 流量控制\拥塞控制 ||
|TCP 半连接队列 ||
|TCP 半关闭状态 ||
|TCP TIME_WAIT 状态 ||
|内核态\用户态 ||
|Hash 实现\冲突解决\应用 ||
|快速排序||
|堆排序||
|大小堆 ||
|100 枚硬币,其中有一枚硬币重量不一样,用天平秤怎么快速找到这一枚硬币||

# 跟谁学

|Q|A|
|:---:|:---:|
|说一下Redis中HashMap的实现(双table,渐进式rehash,扩容条件,缩容条件,bgsave,CopyOnWrite机制) ||
|扩容过程中有新的请求流程||
|Redis其他的数据结构(SDS,RAW,INTSET,ZIPLIST,SKIPLIST,QUICKLIST) ||
|跳表的实现?||
|Redis的定时任务怎么实现的?||
|订单服务过期是怎么设计的(RabbitMQ死信队列)||

# 百度

|Q|A|
|:---:|:---:|
|数据库问题,给你10个数据库服务器,每个只能接500的qps,现在要实现4000qps,要怎么做?说用负载均衡,使用binlog保证10个服务器的数据一致性 ||
|如果有读有写,如何实现高并发,数据库读写分离 ||
|对于两个写库,两个请求向分别打到两个写库中,他们互相向对方同步,会不会出现不一致,||
|哈希的实现有哪几种,如何取hashcode,冲突检测几种方法 ||
|用过go,那么进程,协程,线程各自的优缺点 ||
|算法题:遍历二叉树,循环有序数组找指定值 |[![遍历二叉树](https://z3.ax1x.com/2021/03/25/6O7QjH.png)](https://raw.githubusercontent.com/zhangyiming748/zhangyiming748.github.io/master/code/traverse_the_binary_tree.go)|
|事务是怎么实现的?(undo_log,MVCC) ||
|mongodb和redis的区别||
|请你说说golang的CSP思想||
|go 内存逃逸分析(分析了栈帧,讲五种例子,描述堆栈优缺点,点头)||
|是否有逃逸分析过||
|defer recover 的问题||
|mysql 索引慢分析(线上开启slowlog,提取慢查询,然后仔细分析explain 中 tye字段以及extra字段,发生的具体场景及mysql是怎么做的||

# redis

|Q|A|
|:---:|:---:|
|什么是redis|**内存型非结构化KV数据库**<br>redis是一个高性能的key-value数据库,它是完全开源免费的,而且redis是一个NOSQL类型数据库,是为了解决高并发\高扩展,大数据存储等一系列的问题而产生的数据库解决方案,是一个非关系型的数据库|
|Reids的特点|Redis本质上是一个Key-Value类型的内存数据库,很像memcached,整个数据库统统加载在内存当中进行操作,定期通过异步操作把数据库数据flush到硬盘上进行保存.因为是纯内存操作,Redis的性能非常出色,每秒可以处理超过 **10万次读写操作**,是已知性能最快的Key-Value DB<br>Redis的出色之处不仅仅是性能,Redis最大的魅力是支持保存多种数据结构,此外单个value的最大限制是1GB,不像 memcached只能保存1MB的数据,因此Redis可以用来实现很多有用的功能,比方说用他的List来做FIFO双向链表,实现一个轻量级的高性 能消息队列服务,用他的Set可以做高性能的tag系统等等.另外Redis也可以对存入的Key-Value设置expire时间,因此也可以被当作一 个功能加强版的memcached来用<br>Redis的主要缺点是数据库容量受到物理内存的限制,不能用作海量数据的高性能读写,因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上.|
|使用redis有哪些好处|速度快,因为数据存在内存中,类似于HashMap,HashMap的优势就是查找和操作的时间复杂度都是O(1)<br>支持丰富数据类型,支持string,list,set,sorted set,hash|
|redis相比memcached有哪些优势|memcached所有的值均是简单的字符串,redis作为其替代者,支持更为丰富的数据类型<br>redis的速度比memcached快很多<br>redis可以持久化其数据|
|Memcache与Redis的区别都有哪些|存储方式 Memecache把数据全部存在内存之中,断电后会挂掉,数据不能超过内存大小.Redis有部份存在硬盘上,这样能保证数据的持久性.<br>数据支持类型 Memcache对数据类型支持相对简单.Redis有复杂的数据类型<br>使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样.Redis直接自己构建了VM 机制 ,因为一般的系统调用系统函数的话,会浪费一定的时间去移动和请求.|
|redis适用于的场景|**会话缓存(Session Cache)**最常用的一种使用Redis的情景是会话缓存(session cache).用Redis缓存会话比其他存储(如Memcached)的优势在于:Redis提供持久化.<br>**全页缓存(FPC)**除基本的会话token之外,Redis还提供很简便的FPC平台.回到一致性问题,即使重启了Redis实例,因为有磁盘的持久化,用户也不会看到页面加载速度的下降,这是一个极大改进,类似PHP本地FPC.<br>**队列**Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作,这使得Redis能作为一个很好的消息队列平台来使用.Redis作为队列使用的操作,就类似于本地程序语言(如Python)对 list 的 push/pop 操作.如果你快速的在Google中搜索"Redis queues",你马上就能找到大量的开源项目,这些项目的目的就是利用Redis创建非常好的后端工具,以满足各种队列需求.例如,Celery有一个后台就是使用Redis作为broker,你可以从这里去查看.<br>**排行榜/计数器**Redis在内存中对数字进行递增或递减的操作实现的非常好.集合(Set)和有序集合(Sorted Set)也使得我们在执行这些操作的时候变的非常简单,Redis只是正好提供了这两种数据结构.所以,我们要从排序集合中获取到排名最靠前的10个用户–我们称之为"user_scores",我们只需要像下面一样执行即可:当然,这是假定你是根据你用户的分数做递增的排序.如果你想返回用户及用户的分数,你需要这样执行:ZRANGE user_scores 0 10 WITHSCORES.Agora Games就是一个很好的例子,用Ruby实现的,它的排行榜就是使用Redis来存储数据的,你可以在这里看到.<br>**发布/订阅**发布/订阅的使用场景确实非常多.|
|redis的缓存失效策略和主键失效机制||
|为什么redis需要把所有数据放到内存中||
|Redis是单进程单线程的||
|redis的并发竞争问题如何解决||
|redis常见性能问题和解决方案||
|redis事物的了解CAS(check-and-set 操作实现乐观锁 )||
|WATCH命令和基于CAS的乐观锁||
|使用过Redis分布式锁么,它是什么回事||
|假如Redis里面有1亿个key,其中有10w个key是以某个固定的已知的前缀开头的,如果将它们全部找出来?||
|使用过Redis做异步队列么,你是怎么用的||
|如果有大量的key需要设置同一时间过期,一般需要注意什么||
|Redis如何做持久化的||
|Pipeline有什么好处,为什么要用pipeline||
|Redis的同步机制了解么||
|是否使用过Redis集群,集群的原理是什么||
|||
|||
|||
|||
|||
|||
|||
|||
|||
|||
|||
|||
|||
|||
|||
|||
|||
|||
|||
|||
|||
|||
|||
|||
|||
