---
layout:     post                    # 使用的布局(不需要改)
title:      Linux命令大全             # 标题
subtitle:   我是一只被禁足的安小鸟 #副标题
date:       2020-08-25 00:00:00 GMT+0800             # 时间
author:     Zen                 # 作者
header-img: img/photo/birdAngle.webp    #这篇文章标题背景图片
catalog: False                     # 是否归档
tags:                               #标签
    - Linux学习


<h3>一、基本操作命令</h3> <p><strong>首先先来几个热键，非常方便，一定要记住</strong></p> <p><strong>Tab按键—命令补齐功能</strong></p> <p><strong>Ctrl+c按键—停掉正在运行的程序</strong></p> <p><strong>Ctrl+d按键—相当于exit，退出</strong></p> <p><strong>Ctrl+l按键—清屏</strong></p> <h4>1.1 关机和重启</h4> <p><strong>1.关机命令：shutdown</strong></p> <p>在linux领域内大多用在服务器上，很少遇到关机的操作。毕竟服务器上跑一个服务是永无止境的，除非特殊情况下，不得已才会关机。</p> <p>正确的关机流程为：<strong>sync &gt; shutdown &gt; reboot &gt; halt</strong></p> <p>例如你可以运行如下命令关机：</p> <pre>sync 将数据由内存同步到硬盘中。

shutdown 关机指令，你可以man shutdown 来看一下帮助文档。例如你可以运行如下命令关机：

shutdown –h 10 ‘This server will shutdown after 10 mins’ 这个命令告诉大家，计算机将在10分钟后关机，并且会显示在登陆用户的当前屏幕中。

shutdown –h now 立马关机

shutdown –h 20:25 系统会在今天20:25关机

shutdown –h +10 十分钟后关机

shutdown –r now 系统立马重启

shutdown –r +10 系统十分钟后重启

reboot 就是重启，等同于 shutdown –r now

halt 关闭系统，等同于shutdown –h now 和 poweroff
</pre> <p>下面是一个简单的样例。</p> <figure><img src="https://img-blog.csdn.net/20170119140908226"></figure> <p><strong>取消定时关机命令：shutdown -c</strong></p> <p>最后总结一下，不管是重启系统还是关闭系统，首先要运行 <strong>sync</strong> 命令，把内存中的数据写到磁盘中。</p> <p>关机的命令有 <strong>shutdown –h now halt poweroff</strong> 和 <strong>init 0</strong> , 重启系统的命令有 <strong>shutdown –r now reboot init 6</strong>。</p> <p><strong>2.重启命令：reboot</strong> </p><figure><img src="https://img-blog.csdn.net/20170119141151302"></figure> <h4>1.2 帮助命令</h4> <p>–help命令 shutdown --help： ifconfig --help：查看网卡信息</p> <p>man命令（命令说明书） man shutdown 注意：man shutdown打开命令说明书之后，使用按键q退出</p> <h3>二、目录操作命令</h3> <p>我们知道Linux的目录结构为树状结构，最顶级的目录为根目录 /。</p> <p>其他目录通过挂载可以将它们添加到树中，通过解除挂载可以移除它们。</p> <p>首先我们需要先知道什么是绝对路径与相对路径。</p> <ul><li><strong>绝对路径：</strong> 路径的写法，由根目录 / 写起，例如： /usr/share/doc 这个目录。</li><li><strong>相对路径：</strong> 路径的写法，不是由 / 写起，例如由 /usr/share/doc 要到 /usr/share/man 底下时，可以写成： cd …/man 这就是相对路径的写法啦！</li></ul> <h4>2.1 目录切换 cd</h4> <p>命令：cd 目录</p> <p>cd是Change Directory的缩写，这是用来变换工作目录的命令。</p> <pre>cd /        切换到根目录
cd /usr        切换到根目录下的usr目录
cd ../        切换到上一级目录 或者  cd ..
cd ~        切换到home目录
cd -        切换到上次访问的目录
</pre> <h4>2.2 目录查看 ls [-al]</h4> <p>命令：ls [-al]</p> <p>语法：</p> <pre>ls [-aAdfFhilnrRSt] 目录名称
ls [--color={never,auto,always}] 目录名称
ls [--full-time] 目录名称
</pre> <p>ls 查看当前目录下的所有目录和文件 ls -a 查看当前目录下的所有目录和文件（包括隐藏的文件） ls -l 或 ll 列表查看当前目录下的所有目录和文件（列表查看，显示更多信息） ls /dir 查看指定目录下的所有目录和文件 如：ls /usr</p> <p>将家目录下的所有文件列出来(含属性与隐藏档)</p> <pre>ls -al ~
</pre> <h4>2.3 目录操作【增，删，改，查】</h4> <h3>2.3.1 创建目录【增】 mkdir</h3> <p>如果想要创建新的目录的话，那么就使用mkdir (make directory)吧。</p> <p>语法：</p> <pre>mkdir [-mp] 目录名称
</pre> <p>选项与参数：</p> <ul><li>-m ：配置文件的权限喔！直接配置，不需要看默认权限 (umask) 的脸色～</li><li>-p ：帮助你直接将所需要的目录(包含上一级目录)递归创建起来！</li></ul> <p>实例：请到/tmp底下尝试创建数个新目录看看：</p> <pre>cd /tmp
[root@www tmp] mkdir test    &lt;==创建一名为 test 的新目录
[root@www tmp] mkdir test1/test2/test3/test4
mkdir: cannot create directory `test1/test2/test3/test4': 
No such file or directory       &lt;== 没办法直接创建此目录啊！
[root@www tmp] mkdir -p test1/test2/test3/test4
</pre> <p>加了这个 -p 的选项，可以自行帮你创建多层目录！</p> <p>实例：创建权限为 <strong>rwx–x--x</strong> 的目录。</p> <pre>[root@www tmp] mkdir -m 711 test2
[root@www tmp] ls -l
drwxr-xr-x  3 root  root 4096 Jul 18 12:50 test
drwxr-xr-x  3 root  root 4096 Jul 18 12:53 test1
drwx--x--x  2 root  root 4096 Jul 18 12:54 test2
</pre> <p>上面的权限部分，如果没有加上 -m 来强制配置属性，系统会使用默认属性。</p> <p>如果我们使用 -m ，如上例我们给予 -m 711 来给予新的目录 drwx–x--x 的权限。</p> <h3>2.3.2 删除目录或文件【删】rm</h3> <pre> rm [-fir] 文件或目录
</pre> <p>选项与参数：</p> <ul><li>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；</li><li>-i ：互动模式，在删除前会询问使用者是否动作</li><li>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！</li></ul> <p><strong>删除文件：</strong> rm 文件 删除当前目录下的文件 rm -f 文件 删除当前目录的的文件（不询问）</p> <p><strong>删除目录：</strong> rm -r aaa 递归删除当前目录下的aaa目录 rm -rf aaa 递归删除当前目录下的aaa目录（不询问）</p> <p><strong>全部删除：</strong> rm -rf * 将当前目录下的所有目录和文件全部删除 rm -rf /* **【自杀命令！慎用！慎用！慎用！】**将根目录下的所有文件全部删除</p> <p>注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了方便大家的记忆，无论删除任何目录或文件，都直接使用 rm -rf 目录/文件/压缩包</p> <h3>rmdir (删除空的目录)</h3> <p>语法：</p> <pre> rmdir [-p] 目录名称
</pre> <p>选项与参数：</p> <ul><li>**-p ：**连同上一级『空的』目录也一起删除</li></ul> <p>删除 runoob 目录</p> <pre>[root@www tmp] rmdir runoob/
</pre> <p>将 mkdir 实例中创建的目录(/tmp 底下)删除掉！</p> <pre>[root@www tmp] ls -l   &lt;==看看有多少目录存在？
drwxr-xr-x  3 root  root 4096 Jul 18 12:50 test
drwxr-xr-x  3 root  root 4096 Jul 18 12:53 test1
drwx--x--x  2 root  root 4096 Jul 18 12:54 test2
[root@www tmp] rmdir test   &lt;==可直接删除掉，没问题
[root@www tmp] rmdir test1  &lt;==因为尚有内容，所以无法删除！
rmdir: `test1': Directory not empty
[root@www tmp] rmdir -p test1/test2/test3/test4
[root@www tmp] ls -l        &lt;==您看看，底下的输出中test与test1不见了！
drwx--x--x  2 root  root 4096 Jul 18 12:54 test2
</pre> <p>利用 -p 这个选项，立刻就可以将 test1/test2/test3/test4 一次删除。</p> <p>不过要注意的是，这个 rmdir 仅能删除空的目录，你可以使用 rm 命令来删除非空目录。</p> <h3>2.3.3 目录修改【改】mv 和 cp</h3> <p><strong>mv (移动文件与目录，或修改名称)</strong></p> <p>语法：</p> <pre>[root@www ~] mv [-fiu] source destination
[root@www ~] mv [options] source1 source2 source3 .... directory
</pre> <p>选项与参数：</p> <ul><li>-f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</li><li>-i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！</li><li>-u ：若目标文件已经存在，且 source 比较新，才会升级 (update)</li></ul> <p><strong>cp (复制文件或目录)</strong></p> <p>cp 即拷贝文件和目录。</p> <p>语法:</p> <pre>[root@www ~] cp [-adfilprsu] 来源档(source) 目标档(destination)
[root@www ~] cp [options] source1 source2 source3 .... directory
</pre> <p>选项与参数：</p> <ul><li>-a：相当於 -pdr 的意思，至於 pdr 请参考下列说明；(常用)</li><li>-d：若来源档为连结档的属性(link file)，则复制连结档属性而非文件本身；</li><li>-f：为强制(force)的意思，若目标文件已经存在且无法开启，则移除后再尝试一次；</li><li>-i：若目标档(destination)已经存在时，在覆盖时会先询问动作的进行(常用)</li><li>-l：进行硬式连结(hard link)的连结档创建，而非复制文件本身；</li><li>-p：连同文件的属性一起复制过去，而非使用默认属性(备份常用)；</li><li>-r：递归持续复制，用於目录的复制行为；(常用)</li><li>-s：复制成为符号连结档 (symbolic link)，亦即『捷径』文件；</li><li>-u：若 destination 比 source 旧才升级 destination ！</li></ul> <p><strong>一、重命名目录</strong> 命令：mv 当前目录 新目录 例如：mv aaa bbb 将目录aaa改为bbb 注意：mv的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行 重命名的操作</p> <p><strong>二、剪切目录</strong> 命令：mv 目录名称 目录的新位置 示例：将/usr/tmp目录下的aaa目录剪切到 /usr目录下面 mv /usr/tmp/aaa /usr 注意：mv语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作</p> <p><strong>三、拷贝目录</strong> 命令：cp -r 目录名称 目录拷贝的目标位置 -r代表递归 示例：将/usr/tmp目录下的aaa目录复制到 /usr目录下面 cp /usr/tmp/aaa /usr 注意：cp命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不 用写-r递归</p> <h3>2.3.4 搜索目录【查】find</h3> <p>Linux find 命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则 find 命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。</p> <pre>find   path   -option   [   -print ]   [ -exec   -ok   command ]   {} \;
</pre> <p>命令：find 目录 参数 文件名称</p> <p><strong>部分参数：</strong></p> <p>find 根据下列规则判断 path 和 expression，在命令列上第一个 - ( ) , ! 之前的部份为 path，之后的是 expression。如果 path 是空字串则使用目前路径，如果 expression 是空字串则使用 -print 为预设 expression。</p> <p>expression 中可使用的选项有二三十个之多，在此只介绍最常用的部份。</p> <p>-mount, -xdev : 只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件</p> <p>-amin n : 在过去 n 分钟内被读取过</p> <p>-anewer file : 比文件 file 更晚被读取过的文件</p> <p>-atime n : 在过去n天内被读取过的文件</p> <p>-cmin n : 在过去 n 分钟内被修改过</p> <p>-cnewer file :比文件 file 更新的文件</p> <p>-ctime n : 在过去n天内被修改过的文件</p> <p><strong>实例</strong></p> <p>将目前目录及其子目录下所有延伸档名是 c 的文件列出来。</p> <pre>find . -name "*.c"
</pre> <p>将目前目录其其下子目录中所有一般文件列出</p> <pre>find . -type f
</pre> <p>将目前目录及其子目录下所有最近 20 天内更新过的文件列出</p> <pre>find . -ctime -20
</pre> <h4>2.4 当前目录显示 pwd</h4> <h3>pwd (显示目前所在的目录)</h3> <p>pwd 是 <strong>Print Working Directory</strong> 的缩写，也就是显示目前所在目录的命令。</p> <pre>[root@www ~] pwd [-P]
</pre> <p>选项与参数：</p> <ul><li><strong>-P</strong> ：显示出确实的路径，而非使用连结 (link) 路径。</li></ul> <p>实例：单纯显示出目前的工作目录：</p> <pre>[root@www ~] pwd
/root   &lt;== 显示出目录啦～
</pre> <p>实例显示出实际的工作目录，而非连结档本身的目录名而已。</p> <pre>[root@www ~] cd /var/mail   &lt;==注意，/var/mail是一个连结档
[root@www mail] pwd
/var/mail         &lt;==列出目前的工作目录
[root@www mail] pwd -P
/var/spool/mail   &lt;==怎么回事？有没有加 -P 差很多～
[root@www mail] ls -ld /var/mail
lrwxrwxrwx 1 root root 10 Sep  4 17:54 /var/mail -&gt; spool/mail
 
 
</pre> <h3>三、文件操作命令</h3> <h4>3.1 文件操作【增，删，改，查】</h4> <h3>3.1.1 新建文件【增】touch</h3> <p>Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p> <p>ls -l 可以显示档案的时间记录。</p> <h3>语法</h3> <pre>touch [-acfm][-d&lt;日期时间&gt;][-r&lt;参考文件或目录&gt;] [-t&lt;日期时间&gt;][--help][--version][文件或目录…]
</pre> <ul><li><strong>参数说明</strong>：</li><li>a 改变档案的读取时间记录。</li><li>m 改变档案的修改时间记录。</li><li>c 假如目的档案不存在，不会建立新的档案。与 --no-create 的效果一样。</li><li>f 不使用，是为了与其他 unix 系统的相容性而保留。</li><li>r 使用参考档的时间记录，与 --file 的效果一样。</li><li>d 设定时间与日期，可以使用各种不同的格式。</li><li>t 设定档案的时间记录，格式与 date 指令相同。</li><li>–no-create 不会建立新档案。</li><li>–help 列出指令格式。</li><li>–version 列出版本讯息。</li></ul> <h3>实例</h3> <p>使用指令"touch"修改文件"testfile"的时间属性为当前系统时间，输入如下命令：</p> <pre>$ touch testfile                 
</pre> <p>首先，使用ls命令查看testfile文件的属性，如下所示：</p> <pre>$ ls -l testfile                 
 
-rw-r--r-- 1 hdd hdd 55 2011-08-22 16:09 testfile  
</pre> <p>执行指令"touch"修改文件属性以后，并再次查看该文件的时间属性，如下所示：</p> <pre>$ touch testfile                 
$ ls -l testfile                 
 
-rw-r--r-- 1 hdd hdd 55 2011-08-22 19:53 testfile  
</pre> <p>使用指令"touch"时，如果指定的文件不存在，则将创建一个新的空白文件。例如，在当前目录下，使用该指令创建一个空白文件"file"，输入如下命令：</p> <pre>$ touch file             
</pre> <h3>3.1.2 删除文件 【删】 rm</h3> <p><strong>rm (移除文件或目录)</strong></p> <p>语法：</p> <pre> rm [-fir] 文件或目录
</pre> <p>选项与参数：</p> <ul><li> <p>-f ：就是 force 的意思，忽略不存在的文件，不会出现警告信息；</p> </li><li> <p>-i ：互动模式，在删除前会询问使用者是否动作</p> </li><li> <p>-r ：递归删除啊！最常用在目录的删除了！这是非常危险的选项！！！</p> </li></ul> <p>将创建的 bashrc 删除掉！</p> <pre>[root@www tmp] 
rm: remove regular file `bashrc'? y
</pre> <p>如果加上 -i 的选项就会主动询问喔，避免你删除到错误的档名！</p> <h3>3.1.3 修改文件【改】 vi或vim</h3> <p><strong>先来个vim键盘图！</strong></p> <figure><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly93d3cucnVub29iLmNvbS93cC1jb250ZW50L3VwbG9hZHMvMjAxNS8xMC92aS12aW0tY2hlYXQtc2hlZXQtc2NoLmdpZg"></figure> <p><strong>vi/vim 的使用</strong></p> <p>基本上 vi/vim 共分为三种模式，分别是<strong>命令模式（Command mode）</strong>，<strong>输入模式（Insert mode）<strong>和</strong>底线命令模式（Last line mode）</strong>。 这三种模式的作用分别是：</p> <h3>命令模式：</h3> <p>用户刚刚启动 vi/vim，便进入了命令模式。</p> <p>此状态下敲击键盘动作会被Vim识别为命令，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。</p> <p>以下是常用的几个命令：</p> <ul><li><strong>i</strong> 切换到输入模式，以输入字符。</li><li><strong>x</strong> 删除当前光标所在处的字符。</li><li><strong>:</strong> 切换到底线命令模式，以在最底一行输入命令。</li></ul> <p>若想要编辑文本：启动Vim，进入了命令模式，按下i，切换到输入模式。</p> <p>命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。</p> <h3>输入模式</h3> <p>在命令模式下按下i就进入了输入模式。</p> <p>在输入模式中，可以使用以下按键：</p> <ul><li><strong>字符按键以及Shift组合</strong>，输入字符</li><li><strong>ENTER</strong>，回车键，换行</li><li><strong>BACK SPACE</strong>，退格键，删除光标前一个字符</li><li><strong>DEL</strong>，删除键，删除光标后一个字符</li><li><strong>方向键</strong>，在文本中移动光标</li><li><strong>HOME</strong>/<strong>END</strong>，移动光标到行首/行尾</li><li><strong>Page Up</strong>/<strong>Page Down</strong>，上/下翻页</li><li><strong>Insert</strong>，切换光标为输入/替换模式，光标将变成竖线/下划线</li><li><strong>ESC</strong>，退出输入模式，切换到命令模式</li></ul> <h3>底线命令模式</h3> <p>在命令模式下按下:（英文冒号）就进入了底线命令模式。</p> <p>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。</p> <p>在底线命令模式中，基本的命令有（已经省略了冒号）：</p> <ul><li>q 退出程序</li><li>w 保存文件</li></ul> <p>按ESC键可随时退出底线命令模式。</p> <p>简单的说，我们可以将这三个模式想成底下的图标来表示：</p> <figure><img src="https://img-blog.csdnimg.cn/2019010522374780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ludGZsb2p4,size_16,color_FFFFFF,t_70"></figure> <p><strong>打开文件</strong></p> <p>命令：vi 文件名 示例：打开当前目录下的aa.txt文件 vi aa.txt 或者 vim aa.txt</p> <p>注意：使用vi编辑器打开文件后，并不能编辑，因为此时处于命令模式，点击键盘i/a/o进入编辑模式。</p> <p><strong>编辑文件</strong></p> <p>使用vi编辑器打开文件后点击按键：i ，a或者o即可进入编辑模式。</p> <p>i:在光标所在字符前开始插入 a:在光标所在字符后开始插入 o:在光标所在行的下面另起一新行插入</p> <figure><img src="https://img-blog.csdnimg.cn/20190105223929889.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ludGZsb2p4,size_16,color_FFFFFF,t_70"></figure> <p>保存或者取消编辑</p> <p><strong>保存文件：</strong></p> <p>第一步：ESC 进入命令行模式 第二步：: 进入底行模式 第三步：wq 保存并退出编辑</p> <p><strong>取消编辑：</strong></p> <p>第一步：ESC 进入命令行模式 第二步：: 进入底行模式 第三步：q! 撤销本次修改并退出编辑</p> <h3>3.1.4 文件的查看【查】</h3> <p>Linux系统中使用以下命令来查看文件的内容：</p> <ul><li>cat 由第一行开始显示文件内容</li><li>tac 从最后一行开始显示，可以看出 tac 是 cat 的倒着写！</li><li>nl 显示的时候，顺道输出行号！</li><li>more 一页一页的显示文件内容</li><li>less 与 more 类似，但是比 more 更好的是，他可以往前翻页！</li><li>head 只看头几行</li><li>tail 只看尾巴几行</li></ul> <p>你可以使用 *man [命令]*来查看各个命令的使用文档，如 ：man cp。</p> <h3>cat</h3> <p>由第一行开始显示文件内容</p> <p>语法：</p> <pre>cat [-AbEnTv]
</pre> <p>选项与参数：</p> <ul><li>-A ：相当於 -vET 的整合选项，可列出一些特殊字符而不是空白而已；</li><li>-b ：列出行号，仅针对非空白行做行号显示，空白行不标行号！</li><li>-E ：将结尾的断行字节 $ 显示出来；</li><li>-n ：列印出行号，连同空白行也会有行号，与 -b 的选项不同；</li><li>-T ：将 [tab] 按键以 ^I 显示出来；</li><li>-v ：列出一些看不出来的特殊字符</li></ul> <p>检看 /etc/issue 这个文件的内容：</p> <pre>[root@www ~] cat /etc/issue
CentOS release 6.4 (Final)
Kernel \r on an \m
</pre> <h3>tac</h3> <p>tac与cat命令刚好相反，文件内容从最后一行开始显示，可以看出 tac 是 cat 的倒着写！如：</p> <pre>[root@www ~] tac /etc/issue

Kernel \r on an \m
CentOS release 6.4 (Final)
</pre> <h3>nl</h3> <p>显示行号</p> <p>语法：</p> <pre>nl [-bnw] 文件
</pre> <p>选项与参数：</p> <ul><li>-b ：指定行号指定的方式，主要有两种： -b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)； -b t ：如果有空行，空的那一行不要列出行号(默认值)；</li><li>-n ：列出行号表示的方法，主要有三种： -n ln ：行号在荧幕的最左方显示； -n rn ：行号在自己栏位的最右方显示，且不加 0 ； -n rz ：行号在自己栏位的最右方显示，且加 0 ；</li><li>-w ：行号栏位的占用的位数。</li></ul> <p>实例一：用 nl 列出 /etc/issue 的内容</p> <pre>[root@www ~] nl /etc/issue
     1  CentOS release 6.4 (Final)
     2  Kernel \r on an \m
</pre> <h3>more</h3> <p>一页一页翻动</p> <pre>[root@www ~] more /etc/man_db.config 
 
 
 
 
 
....(中间省略)....
--More--(28%)  &lt;== 重点在这一行喔！你的光标也会在这里等待你的命令
</pre> <p>在 more 这个程序的运行过程中，你有几个按键可以按的：</p> <ul><li>空白键 (space)：代表向下翻一页；</li><li>Enter ：代表向下翻『一行』；</li><li>/字串 ：代表在这个显示的内容当中，向下搜寻『字串』这个关键字；</li><li>:f ：立刻显示出档名以及目前显示的行数；</li><li>q ：代表立刻离开 more ，不再显示该文件内容。</li><li>b 或 [ctrl]-b ：代表往回翻页，不过这动作只对文件有用，对管线无用。</li></ul> <h3>less</h3> <p>一页一页翻动，以下实例输出/etc/man.config文件的内容：</p> <pre>[root@www ~] less /etc/man.config
 
 
 
 
 
....(中间省略)....
:   &lt;== 这里可以等待你输入命令！
</pre> <p>less运行时可以输入的命令有：</p> <ul><li>空白键 ：向下翻动一页；</li><li>[pagedown]：向下翻动一页；</li><li>[pageup] ：向上翻动一页；</li><li>/字串 ：向下搜寻『字串』的功能；</li><li>?字串 ：向上搜寻『字串』的功能；</li><li>n ：重复前一个搜寻 (与 / 或 ? 有关！)</li><li>N ：反向的重复前一个搜寻 (与 / 或 ? 有关！)</li><li>q ：离开 less 这个程序；</li></ul> <h3>head</h3> <p>取出文件前面几行</p> <p>语法：</p> <pre>head [-n number] 文件 
</pre> <p>选项与参数：</p> <ul><li>-n ：后面接数字，代表显示几行的意思</li></ul> <pre>[root@www ~] head /etc/man.config
</pre> <p>默认的情况中，显示前面 10 行！若要显示前 20 行，就得要这样：</p> <pre>[root@www ~] head -n 20 /etc/man.config
</pre> <h3>tail</h3> <p>取出文件后面几行</p> <p>语法：</p> <pre>tail [-n number] 文件 
</pre> <p>选项与参数：</p> <ul><li>-n ：后面接数字，代表显示几行的意思</li><li>-f ：表示持续侦测后面所接的档名，要等到按下[ctrl]-c才会结束tail的侦测</li></ul> <pre>[root@www ~] tail /etc/man.config
 
[root@www ~] tail -n 20 /etc/man.config
</pre> <h4>3.2 权限修改</h4> <p>Linux/Unix 的文件调用权限分为三级 : 文件拥有者、群组、其他。利用 chmod 可以藉以控制文件如何被他人所调用。</p> <p><strong>使用权限</strong> : 所有使用者</p> <h3>语法</h3> <pre>chmod [-cfvR] [--help] [--version] mode file...
</pre> <h3>参数说明</h3> <p>mode : 权限设定字串，格式如下 :</p> <pre>[ugoa...][[+-=][rwxX]...][,...]
</pre> <p>其中：</p> <ul><li>u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。</li><li>+ 表示增加权限、- 表示取消权限、= 表示唯一设定权限。</li><li>r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。</li></ul> <p>其他参数说明：</p> <ul><li>-c : 若该文件权限确实已经更改，才显示其更改动作</li><li>-f : 若该文件权限无法被更改也不要显示错误讯息</li><li>-v : 显示权限变更的详细资料</li><li>-R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)</li><li>–help : 显示辅助说明</li><li>–version : 显示版本</li></ul> <p>权限的设定方法有两种， 分别可以使用数字或者是符号来进行权限的变更。</p> <p><strong>数字类型改变档案权限：</strong></p> <figure><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dWNodWFuZzY2Ni5vc3MtY24tc2hlbnpoZW4uYWxpeXVuY3MuY29tL2ltZy9pbWFnZS0yMDIwMDYyMzIzNTAxODIzOC5wbmc?x-oss-process=image/format,png"></figure> <p><strong>符号类型改变档案权限：</strong></p> <figure><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly90dWNodWFuZzY2Ni5vc3MtY24tc2hlbnpoZW4uYWxpeXVuY3MuY29tL2ltZy9pbWFnZS0yMDIwMDYyMzIzNTAyNjI0My5wbmc?x-oss-process=image/format,png"></figure> <h3>四、压缩文件操作</h3> <p>Linux 常用的压缩与解压缩命令有：tar、gzip、gunzip、bzip2、bunzip2、compress 、uncompress、 zip、 unzip、rar、unrar 等。</p> <h4>4.1 打包和压缩和解压</h4> <p>Windows的压缩文件的扩展名 .zip/.rar linux中的打包文件：aa.tar linux中的压缩文件：bb.gz linux中打包并压缩的文件：.tar.gz</p> <p>Linux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。 而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。</p> <p><strong>tar</strong></p> <p>最常用的打包命令是 tar，使用 tar 程序打出来的包我们常称为 tar 包，tar 包文件的命令通常都是以 .tar 结尾的。生成 tar 包后，就可以用其它的程序来进行压缩了，所以首先就来讲讲 tar 命令的基本用法。</p> <p>tar 命令的选项有很多(用 man tar 可以查看到)，但常用的就那么几个选项，下面来举例说明一下：</p> <pre> tar -cf all.tar *.jpg
</pre> <p>这条命令是将所有 .jpg 的文件打成一个名为 all.tar 的包。-c 是表示产生新的包，-f 指定包的文件名。</p> <pre> tar -rf all.tar *.gif
</pre> <p>这条命令是将所有 .gif 的文件增加到 all.tar 的包里面去，-r 是表示增加文件的意思。</p> <pre> tar -uf all.tar logo.gif
</pre> <p>这条命令是更新原来 tar 包 all.tar 中 logo.gif 文件，-u 是表示更新文件的意思。</p> <pre> tar -tf all.tar
</pre> <p>这条命令是列出 all.tar 包中所有文件，-t 是列出文件的意思。</p> <pre> tar -xf all.tar
</pre> <p>这条命令是解出 all.tar 包中所有文件，-x 是解开的意思。</p> <p>以上就是 tar 的最基本的用法。为了方便用户在打包解包的同时可以压缩或解压文件，tar 提供了一种特殊的功能。这就是 tar 可以在打包或解包的同时调用其它的压缩程序，比如调用 gzip、bzip2 等。</p> <h3>1) tar调用</h3> <p>gzip 是 GNU 组织开发的一个压缩程序，.gz 结尾的文件就是 gzip 压缩的结果。与 gzip 相对的解压程序是 gunzip。tar 中使用 -z 这个参数来调用gzip。下面来举例说明一下：</p> <pre> tar -czf all.tar.gz *.jpg
</pre> <p>这条命令是将所有 .jpg 的文件打成一个 tar 包，并且将其用 gzip 压缩，生成一个 gzip 压缩过的包，包名为 all.tar.gz。</p> <pre> tar -xzf all.tar.gz
</pre> <p>这条命令是将上面产生的包解开。</p> <h3>2) tar 调用 bzip2</h3> <p>bzip2 是一个压缩能力更强的压缩程序，.bz2 结尾的文件就是 bzip2 压缩的结果。</p> <p>与 bzip2 相对的解压程序是 bunzip2。tar 中使用 -j 这个参数来调用 gzip。下面来举例说明一下：</p> <pre> tar -cjf all.tar.bz2 *.jpg
</pre> <p>这条命令是将所有 .jpg 的文件打成一个 tar 包，并且将其用 bzip2 压缩，生成一个 bzip2 压缩过的包，包名为 all.tar.bz2</p> <pre> tar -xjf all.tar.bz2
</pre> <p>这条命令是将上面产生的包解开。</p> <h3>3)tar 调用 compress</h3> <p>compress 也是一个压缩程序，但是好象使用 compress 的人不如 gzip 和 bzip2 的人多。.Z 结尾的文件就是 bzip2 压缩的结果。与 compress 相对的解压程序是 uncompress。tar 中使用 -Z 这个参数来调用 compress。下面来举例说明一下：</p> <pre> tar -cZf all.tar.Z *.jpg
</pre> <p>这条命令是将所有 .jpg 的文件打成一个 tar 包，并且将其用 compress 压缩，生成一个 uncompress 压缩过的包，包名为 all.tar.Z。</p> <pre> tar -xZf all.tar.Z
</pre> <p>这条命令是将上面产生的包解开。</p> <p>有了上面的知识，你应该可以解开多种压缩文件了，下面对于 tar 系列的压缩文件作一个小结：</p> <p><strong>1) 对于.tar结尾的文件</strong></p> <pre>tar -xf all.tar
</pre> <p><strong>2) 对于 .gz 结尾的文件</strong></p> <pre>gzip -d all.gz
gunzip all.gz
</pre> <p><strong>3)对于 .tgz 或 .tar.gz 结尾的文件</strong></p> <pre>tar -xzf all.tar.gz
tar -xzf all.tgz
</pre> <p><strong>4) 对于 .bz2 结尾的文件</strong></p> <pre>bzip2 -d all.bz2
bunzip2 all.bz2
</pre> <p><strong>5) 对于 tar.bz2 结尾的文件</strong></p> <pre>tar -xjf all.tar.bz2
</pre> <p><strong>6) 对于 .Z 结尾的文件</strong></p> <pre>uncompress all.Z
</pre> <p><strong>7) 对于 .tar.Z 结尾的文件</strong></p> <pre>tar -xZf all.tar.z
</pre> <p>另外对于 Windows 下的常见压缩文件 .zip 和 .rar，Linux 也有相应的方法来解压它们：</p> <p><strong>1) 对于 .zip</strong></p> <p>linux 下提供了 zip 和 unzip 程序，zip 是压缩程序，unzip 是解压程序。它们的参数选项很多，这里只做简单介绍，依旧举例说明一下其用法：</p> <pre> zip all.zip *.jpg
</pre> <p>这条命令是将所有 .jpg 的文件压缩成一个 zip 包:</p> <pre> unzip all.zip
</pre> <p>这条命令是将 all.zip 中的所有文件解压出来。</p> <p><strong>2) 对于 .rar</strong></p> <p>要在 linux 下处理 .rar 文件，需要安装 RAR for Linux。下载地址：http://www.rarsoft.com/download.htm，下载后安装即可。</p> <pre> tar -xzpvf rarlinux-x64-5.6.b5.tar.gz
 cd rar 
 make
</pre> <p>这样就安装好了，安装后就有了 rar 和 unrar 这两个程序，rar 是压缩程序，unrar 是解压程序。它们的参数选项很多，这里只做简单介绍，依旧举例说明一下其用法：</p> <pre> rar a all *.jpg
</pre> <p>这条命令是将所有 .jpg 的文件压缩成一个 rar 包，名为 all.rar，该程序会将 .rar 扩展名将自动附加到包名后。</p> <pre> unrar e all.rar
</pre> <p>这条命令是将 all.rar 中的所有文件解压出来</p> <h4>4.2扩展内容</h4> <p><strong>tar</strong></p> <pre>-c: 建立压缩档案 
-x：解压 
-t：查看内容 shell
-r：向压缩归档文件末尾追加文件 
-u：更新原压缩包中的文件
</pre> <p>这五个是独立的命令，压缩解压都要用到其中一个，可以和别的命令连用但只能用其中一个。下面的参数是根据需要在压缩或解压档案时可选的。</p> <pre>-z：有gzip属性的 
-j：有bz2属性的 
-Z：有compress属性的 
-v：显示所有过程 
-O：将文件解开到标准输出 
</pre> <p>下面的参数 -f 是必须的:</p> <pre>-f: 使用档案名字，切记，这个参数是最后一个参数，后面只能接档案名。 
</pre> <p># tar -cf all.tar *.jpg</p> <p>这条命令是将所有 .jpg 的文件打成一个名为 all.tar 的包。-c 是表示产生新的包，-f 指定包的文件名。</p> <pre> tar -rf all.tar *.gif 
</pre> <p>这条命令是将所有 .gif 的文件增加到 all.tar 的包里面去。-r 是表示增加文件的意思。</p> <pre> tar -uf all.tar logo.gif 
</pre> <p>这条命令是更新原来 tar 包 all.tar 中 logo.gif 文件，-u 是表示更新文件的意思。</p> <pre> tar -tf all.tar 
</pre> <p>这条命令是列出 all.tar 包中所有文件，-t 是列出文件的意思。</p> <pre> tar -xf all.tar 
</pre> <p>这条命令是解出 all.tar 包中所有文件，-x 是解开的意思。</p> <p><strong>压缩</strong></p> <pre>tar –cvf jpg.tar *.jpg       // 将目录里所有jpg文件打包成 tar.jpg 
tar –czf jpg.tar.gz *.jpg    // 将目录里所有jpg文件打包成 jpg.tar 后，并且将其用 gzip 压缩，生成一个 gzip 压缩过的包，命名为 jpg.tar.gz 
tar –cjf jpg.tar.bz2 *.jpg   // 将目录里所有jpg文件打包成 jpg.tar 后，并且将其用 bzip2 压缩，生成一个 bzip2 压缩过的包，命名为jpg.tar.bz2 
tar –cZf jpg.tar.Z *.jpg     // 将目录里所有 jpg 文件打包成 jpg.tar 后，并且将其用 compress 压缩，生成一个 umcompress 压缩过的包，命名为jpg.tar.Z 
rar a jpg.rar *.jpg          // rar格式的压缩，需要先下载 rar for linux 
zip jpg.zip *.jpg            // zip格式的压缩，需要先下载 zip for linux
</pre> <p><strong>解压</strong></p> <pre>tar –xvf file.tar         // 解压 tar 包 
tar -xzvf file.tar.gz     // 解压 tar.gz 
tar -xjvf file.tar.bz2    // 解压 tar.bz2 
tar –xZvf file.tar.Z      // 解压 tar.Z 
unrar e file.rar          // 解压 rar 
unzip file.zip            // 解压 zip 
</pre> <p><strong>总结</strong></p> <pre>1、*.tar 用 tar –xvf 解压 
2、*.gz 用 gzip -d或者gunzip 解压 
3、*.tar.gz和*.tgz 用 tar –xzf 解压 
4、*.bz2 用 bzip2 -d或者用bunzip2 解压 
5、*.tar.bz2用tar –xjf 解压 
6、*.Z 用 uncompress 解压 
7、*.tar.Z 用tar –xZf 解压 
8、*.rar 用 unrar e解压 
9、*.zip 用 unzip 解压
</pre> <h3>五、查找命令</h3> <h4>5.1 grep</h4> <p>grep命令是一种强大的文本搜索工具</p> <p>使用实例：</p> <pre>ps -ef | grep sshd  查找指定ssh服务进程 
ps -ef | grep sshd | grep -v grep 查找指定服务进程，排除gerp身 
ps -ef | grep sshd -c 查找指定进程个数 
</pre> <p><strong>从文件内容查找匹配指定字符串的行：</strong></p> <pre>$ grep "被查找的字符串" 文件名
</pre> <p>例子：在当前目录里第一级文件夹中寻找包含指定字符串的 .in 文件</p> <pre>grep "thermcontact" /.in
</pre> <p>从文件内容查找与正则表达式匹配的行：</p> <pre>$ grep –e "正则表达式" 文件名
</pre> <p>查找时不区分大小写：</p> <pre>$ grep –i "被查找的字符串" 文件名
</pre> <p>查找匹配的行数：</p> <p>$ grep -c “被查找的字符串” 文件名</p> <p>从文件内容查找不匹配指定字符串的行：</p> <pre>$ grep –v "被查找的字符串" 文件名
</pre> <h4>5.2 find</h4> <p>find命令在目录结构中搜索文件，并对搜索结果执行指定的操作。</p> <p>find 默认搜索当前目录及其子目录，并且不过滤任何结果（也就是返回所有文件），将它们全都显示在屏幕上。</p> <p>使用实例：</p> <pre>find . -name "*.log" -ls  在当前目录查找以.log结尾的文件，并显示详细信息。 
find /root/ -perm 600   查找/root/目录下权限为600的文件 
find . -type f -name "*.log"  查找当目录，以.log结尾的普通文件 
find . -type d | sort   查找当前所有目录并排序 
find . -size +100M  查找当前目录大于100M的文件
</pre> <p>从根目录开始查找所有扩展名为 .log 的文本文件，并找出包含 “ERROR” 的行：</p> <pre>$ find / -type f -name "*.log" | xargs grep "ERROR"
</pre> <p>例子：从当前目录开始查找所有扩展名为 .in 的文本文件，并找出包含 “thermcontact” 的行：</p> <pre>find . -name "*.in" | xargs grep "thermcontact"
</pre> <h4>5.3 locate</h4> <p>locate 让使用者可以很快速的搜寻某个路径。默认每天自动更新一次，所以使用locate 命令查不到最新变动过的文件。为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。如果数据库中没有查询的数据，则会报出locate: can not stat () `/var/lib/mlocate/mlocate.db’: No such file or directory该错误！updatedb即可！</p> <p>yum -y install mlocate 如果是精简版CentOS系统需要安装locate命令</p> <p>使用实例：</p> <pre>updatedb
locate /etc/sh 搜索etc目录下所有以sh开头的文件 
locate pwd 查找和pwd相关的所有文件
</pre> <h4>5.4 whereis</h4> <p>whereis命令是定位可执行文件、源代码文件、帮助文件在文件系统中的位置。这些文件的属性应属于原始代码，二进制文件，或是帮助文件。</p> <p>使用实例：</p> <pre>whereis ls    将和ls文件相关的文件都查找出来
</pre> <h4>5.5 which</h4> <p>which命令的作用是在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。</p> <p>使用实例：</p> <pre>which pwd  查找pwd命令所在路径 
which java  查找path中java的路径
</pre> <h3>六、su、sudo</h3> <h4>6.1 su</h4> <p>Linux su命令用于变更为其他使用者的身份，除 root 外，需要键入该使用者的密码。</p> <p>使用权限：所有使用者。</p> <h3>语法</h3> <pre>su [-fmp] [-c command] [-s shell] [--help] [--version] [-] [USER [ARG]]
</pre> <p><strong>参数说明</strong>：</p> <ul><li>-f 或 --fast 不必读启动档（如 csh.cshrc 等），仅用于 csh 或 tcsh</li><li>-m -p 或 --preserve-environment 执行 su 时不改变环境变数</li><li>-c command 或 --command=command 变更为帐号为 USER 的使用者并执行指令（command）后再变回原来使用者</li><li>-s shell 或 --shell=shell 指定要执行的 shell （bash csh tcsh 等），预设值为 /etc/passwd 内的该使用者（USER） shell</li><li>–help 显示说明文件</li><li>–version 显示版本资讯</li><li>- -l 或 --login 这个参数加了之后，就好像是重新 login 为该使用者一样，大部份环境变数（HOME SHELL USER等等）都是以该使用者（USER）为主，并且工作目录也会改变，如果没有指定 USER ，内定是 root</li><li>USER 欲变更的使用者帐号</li><li>ARG 传入新的 shell 参数</li></ul> <h3>实例</h3> <p>变更帐号为 root 并在执行 ls 指令后退出变回原使用者</p> <pre>su -c ls root
</pre> <p>变更帐号为 root 并传入 -f 参数给新执行的 shell</p> <pre>su root -f
</pre> <p>变更帐号为 clsung 并改变工作目录至 clsung 的家目录（home dir）</p> <pre>su - clsung
</pre> <p>切换用户</p> <pre>hnlinux@runoob.com:~$ whoami //显示当前用户
hnlinux
hnlinux@runoob.com:~$ pwd //显示当前目录
/home/hnlinux
hnlinux@runoob.com:~$ su root //切换到root用户
密码： 
root@runoob.com:/home/hnlinux 
root
root@runoob.com:/home/hnlinux 
/home/hnlinux
</pre> <p>切换用户，改变环境变量</p> <pre>hnlinux@runoob.com:~$ whoami //显示当前用户
hnlinux
hnlinux@runoob.com:~$ pwd //显示当前目录
/home/hnlinux
hnlinux@runoob.com:~$ su - root //切换到root用户
密码： 
root@runoob.com:/home/hnlinux 
root
root@runoob.com:/home/hnlinux 
/root
</pre> <p>su用于用户之间的切换。但是切换前的用户依然保持登录状态。如果是root 向普通或虚拟用户切换不需要密码，反之普通用户切换到其它任何用户都需要密码验证。</p> <pre>su test:切换到test用户，但是路径还是/root目录
su - test : 切换到test用户，路径变成了/home/test
su : 切换到root用户，但是路径还是原来的路径
su - : 切换到root用户，并且路径是/root
su不足：如果某个用户需要使用root权限、则必须要把root密码告诉此用户。

退出返回之前的用户：exit
</pre> <h4>6.2 sudo</h4> <p>sudo是为所有想使用root权限的普通用户设计的。可以让普通用户具有临时使用root权限的权利。只需输入自己账户的密码即可。</p> <p>进入sudo配置文件命令：</p> <pre>vi /etc/sudoer或者visudo
</pre> <p>案例： 允许hadoop用户以root身份执行各种应用命令，需要输入hadoop用户的密码。 hadoop ALL=(ALL) ALL</p> <p>案例： 只允许hadoop用户以root身份执行ls 、cat命令，并且执行时候免输入密码。 配置文件中： hadoop ALL=NOPASSWD: /bin/ls, /bin/cat</p> <pre>su root -f
</pre> <p>变更帐号为 clsung 并改变工作目录至 clsung 的家目录（home dir）</p> <pre>su - clsung
</pre> <p>切换用户</p> <pre>hnlinux@runoob.com:~$ whoami //显示当前用户
hnlinux
hnlinux@runoob.com:~$ pwd //显示当前目录
/home/hnlinux
hnlinux@runoob.com:~$ su root //切换到root用户
密码： 
root@runoob.com:/home/hnlinux 
root
root@runoob.com:/home/hnlinux 
/home/hnlinux
</pre> <p>切换用户，改变环境变量</p> <pre>hnlinux@runoob.com:~$ whoami //显示当前用户
hnlinux
hnlinux@runoob.com:~$ pwd //显示当前目录
/home/hnlinux
hnlinux@runoob.com:~$ su - root //切换到root用户
密码： 
root@runoob.com:/home/hnlinux 
root
root@runoob.com:/home/hnlinux 
/root
</pre> <p>su用于用户之间的切换。但是切换前的用户依然保持登录状态。如果是root 向普通或虚拟用户切换不需要密码，反之普通用户切换到其它任何用户都需要密码验证。</p> <pre>su test:切换到test用户，但是路径还是/root目录
su - test : 切换到test用户，路径变成了/home/test
su : 切换到root用户，但是路径还是原来的路径
su - : 切换到root用户，并且路径是/root
su不足：如果某个用户需要使用root权限、则必须要把root密码告诉此用户。

退出返回之前的用户：exit
</pre> <h3>七、下载与安装 yum</h3> <p>yum（ Yellow dog Updater, Modified）是一个在Fedora和RedHat以及SUSE中的Shell前端软件包管理器。</p> <p>基於RPM包管理，能够从指定的服务器自动下载RPM包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软体包，无须繁琐地一次次下载、安装。</p> <p>yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p> <h4>yum 语法</h4> <pre>yum [options] [command] [package ...]
</pre> <ul><li>**options：**可选，选项包括-h（帮助），-y（当安装过程提示选择全部为"yes"），-q（不显示安装的过程）等等。</li><li>**command：**要进行的操作。</li><li><strong>package</strong>操作的对象。</li></ul> <h4>yum常用命令</h4> <ul><li>1.列出所有可更新的软件清单命令：yum check-update</li><li>2.更新所有软件命令：yum update</li><li>3.仅安装指定的软件命令：yum install &lt;package_name&gt;</li><li>4.仅更新指定的软件命令：yum update &lt;package_name&gt;</li><li>5.列出所有可安裝的软件清单命令：yum list</li><li>6.删除软件包命令：yum remove &lt;package_name&gt;</li><li>7.查找软件包 命令：yum search </li><li>8.清除缓存命令: <ul><li>yum clean packages: 清除缓存目录下的软件包</li><li>yum clean headers: 清除缓存目录下的 headers</li><li>yum clean oldheaders: 清除缓存目录下旧的 headers</li><li>yum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的headers</li></ul> </li></ul> <h4>实例 1</h4> <p>安装 pam-devel</p> <pre>[root@www ~] yum install pam-devel
Setting up Install Process
Parsing package install arguments
Resolving Dependencies  &lt;==先检查软件的属性相依问题
--&gt; Running transaction check
---&gt; Package pam-devel.i386 0:0.99.6.2-4.el5 set to be updated
--&gt; Processing Dependency: pam = 0.99.6.2-4.el5 for package: pam-devel
--&gt; Running transaction check
---&gt; Package pam.i386 0:0.99.6.2-4.el5 set to be updated
filelists.xml.gz          100% |=========================| 1.6 MB    00:05
filelists.xml.gz          100% |=========================| 138 kB    00:00
-&gt; Finished Dependency Resolution
……(省略)
</pre> <h4>实例 2</h4> <p>移除 pam-devel</p> <pre>[root@www ~] yum remove pam-devel
Setting up Remove Process
Resolving Dependencies  &lt;==同样的，先解决属性相依的问题
--&gt; Running transaction check
---&gt; Package pam-devel.i386 0:0.99.6.2-4.el5 set to be erased
--&gt; Finished Dependency Resolution

Dependencies Resolved

=============================================================================
 Package                 Arch       Version          Repository        Size
=============================================================================
Removing:
 pam-devel               i386       0.99.6.2-4.el5   installed         495 k

Transaction Summary
=============================================================================
Install      0 Package(s)
Update       0 Package(s)
Remove       1 Package(s)  &lt;==还好，并没有属性相依的问题，单纯移除一个软件

Is this ok [y/N]: y
Downloading Packages:
Running rpm_check_debug
Running Transaction Test
Finished Transaction Test
Transaction Test Succeeded
Running Transaction
  Erasing   : pam-devel                     

Removed: pam-devel.i386 0:0.99.6.2-4.el5
Complete!
</pre> <h4>实例 3</h4> <p>利用 yum 的功能，找出以 pam 为开头的软件名称有哪些？</p> <pre>[root@www ~] yum list pam*
Installed Packages
pam.i386                  0.99.6.2-3.27.el5      installed
pam_ccreds.i386           3-5                    installed
pam_krb5.i386             2.2.14-1               installed
pam_passwdqc.i386         1.0.2-1.2.2            installed
pam_pkcs11.i386           0.5.3-23               installed
pam_smb.i386              1.1.7-7.2.1            installed
Available Packages &lt;==底下则是『可升级』的或『未安装』的
pam.i386                  0.99.6.2-4.el5         base
pam-devel.i386            0.99.6.2-4.el5         base
pam_krb5.i386             2.2.14-10              base
</pre> <hr> <h4>国内 yum 源</h4> <p>网易（163）yum源是国内最好的yum源之一 ，无论是速度还是软件版本，都非常的不错。</p> <p>将yum源设置为163 yum，可以提升软件包安装和更新的速度，同时避免一些常见软件版本无法找到。</p> <h3>安装步骤</h3> <p>首先备份/etc/yum.repos.d/CentOS-Base.repo</p> <pre>mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup
</pre> <p>下载对应版本 repo 文件, 放入 /etc/yum.repos.d/ (操作前请做好相应备份)</p> <pre>wget http://mirrors.163.com/.help/CentOS6-Base-163.repo
mv CentOS6-Base-163.repo CentOS-Base.repo
</pre> <p>运行以下命令生成缓存</p> <pre>yum clean all
yum makecache
</pre> <p>除了网易之外，国内还有其他不错的 yum 源，比如中科大和搜狐。</p> <p>中科大的 yum 源，安装方法查看：https://lug.ustc.edu.cn/wiki/mirrors/help/centos</p> <p>sohu 的 yum 源安装方法查看: http://mirrors.sohu.com/help/centos.htm</p> <h3>Linux 三剑客（awk，sed，grep）</h3> <p><strong>awk、sed、grep更适合的方向：</strong></p> <ul><li>grep 更适合单纯的查找或匹配文本</li><li>sed 更适合编辑匹配到的文本</li><li>awk 更适合格式化文本，对文本进行较复杂格式处理</li></ul> <h4>awk</h4> <p>AWK 是一种处理文本文件的语言，是一个强大的文本分析工具。</p> <p>之所以叫 AWK 是因为其取了三位创始人 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 的 Family Name 的首字符。</p> <h3>语法</h3> <pre>awk [选项参数] 'script' var=value file(s)
或
awk [选项参数] -f scriptfile var=value file(s)
</pre> <p><strong>选项参数说明：</strong></p> <ul><li>-F fs or --field-separator fs 指定输入文件折分隔符，fs是一个字符串或者是一个正则表达式，如-F:。</li><li>-v var=value or --asign var=value 赋值一个用户定义变量。</li><li>-f scripfile or --file scriptfile 从脚本文件中读取awk命令。</li><li>-mf nnn and -mr nnn 对nnn值设置内在限制，-mf选项限制分配给nnn的最大块数目；-mr选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。</li><li>-W compact or --compat, -W traditional or --traditional 在兼容模式下运行awk。所以gawk的行为和标准的awk完全一样，所有的awk扩展都被忽略。</li><li>-W copyleft or --copyleft, -W copyright or --copyright 打印简短的版权信息。</li><li>-W help or --help, -W usage or --usage 打印全部awk选项和每个选项的简短说明。</li><li>-W lint or --lint 打印不能向传统unix平台移植的结构的警告。</li><li>-W lint-old or --lint-old 打印关于不能向传统unix平台移植的结构的警告。</li><li>-W posix 打开兼容模式。但有以下限制，不识别：/x、函数关键字、func、换码序列以及当fs是一个空格时，将新行作为一个域分隔符；操作符** 和 **=不能代替^ 和 ^=；fflush无效。</li><li>-W re-interval or --re-inerval 允许间隔正则表达式的使用，参考(grep中的Posix字符类)，如括号表达式[[:alpha:]]。</li><li>-W source program-text or --source program-text 使用program-text作为源代码，可与-f命令混用。</li><li>-W version or --version 打印bug报告信息的版本。</li></ul> <h3>基本用法</h3> <p>log.txt文本内容如下：</p> <pre>2 this is a test
3 Are you like awk
This's a test
10 There are orange,apple,mongo
</pre> <p>用法一：</p> <pre>awk '{[pattern] action}' {filenames}    
</pre> <p>实例：</p> <pre> 
 $ awk '{print $1,$4}' log.txt
 ---------------------------------------------
 2 a
 3 like
 This's
 10 orange,apple,mongo
 # 格式化输出
 $ awk '{printf "%-8s %-10s\n",$1,$4}' log.txt
 ---------------------------------------------
 2        a
 3        like
 This's
 10       orange,apple,mongo
 
</pre> <p>用法二：</p> <pre>awk -F   
</pre> <p>实例：</p> <pre> 
 $  awk -F, '{print $1,$2}'   log.txt
 ---------------------------------------------
 2 this is a test
 3 Are you like awk
 This's a test
 10 There are orange apple
 # 或者使用内建变量
 $ awk 'BEGIN{FS=","} {print $1,$2}'     log.txt
 ---------------------------------------------
 2 this is a test
 3 Are you like awk
 This's a test
 10 There are orange apple
  
 $ awk -F '[ ,]'  '{print $1,$2,$5}'   log.txt
 ---------------------------------------------
 2 this test
 3 Are awk
 This's a
 10 There apple
</pre> <p>用法三：</p> <pre>awk -v   
</pre> <p>实例：</p> <pre> $ awk -va=1 '{print $1,$1+a}' log.txt
 ---------------------------------------------
 2 3
 3 4
 This's 1
 10 11
 $ awk -va=1 -vb=s '{print $1,$1+a,$1b}' log.txt
 ---------------------------------------------
 2 3 2s
 3 4 3s
 This's 1 This'ss
 10 11 10s
</pre> <p>用法四：</p> <pre>awk -f {awk脚本} {文件名}
</pre> <p>实例：</p> <pre> $ awk -f cal.awk log.txt
</pre> <h3>运算符</h3><p> 运算符 描述 = += -= *= /= %= ^= **= 赋值 ?: C条件表达式 || 逻辑或 &amp;&amp; 逻辑与 ~ 和 !~ 匹配正则表达式和不匹配正则表达式 &lt; &lt;= &gt; &gt;= != == 关系运算符 空格 连接 + - 加，减 * / % 乘，除与求余 + - ! 一元加，减和逻辑非 ^ *** 求幂 ++ – 增加或减少，作为前缀或后缀 $ 字段引用 in 数组成员 </p><p>过滤第一列大于2的行</p> <pre>$ awk '$1&gt;2' log.txt     
 
3 Are you like awk
This's a test
10 There are orange,apple,mongo
</pre> <p>过滤第一列等于2的行</p> <pre>$ awk '$1==2 {print $1,$3}' log.txt     
 
2 is
</pre> <p>过滤第一列大于2并且第二列等于’Are’的行</p> <pre>$ awk '$1&gt;2 &amp;&amp; $2=="Are" {print $1,$2,$3}' log.txt     
 
3 Are you
</pre> <h3>内建变量</h3><p> 变量 描述 $n 当前记录的第n个字段，字段间由FS分隔 $0 完整的输入记录 ARGC 命令行参数的数目 ARGIND 命令行中当前文件的位置(从0开始算) ARGV 包含命令行参数的数组 CONVFMT 数字转换格式(默认值为%.6g)ENVIRON环境变量关联数组 ERRNO 最后一个系统错误的描述 FIELDWIDTHS 字段宽度列表(用空格键分隔) FILENAME 当前文件名 FNR 各文件分别计数的行号 FS 字段分隔符(默认是任何空格) IGNORECASE 如果为真，则进行忽略大小写的匹配 NF 一条记录的字段的数目 NR 已经读出的记录数，就是行号，从1开始 OFMT 数字的输出格式(默认值是%.6g) OFS 输出记录分隔符（输出换行符），输出时用指定的符号代替换行符 ORS 输出记录分隔符(默认值是一个换行符) RLENGTH 由match函数所匹配的字符串的长度 RS 记录分隔符(默认是一个换行符) RSTART 由match函数所匹配的字符串的第一个位置 SUBSEP 数组下标分隔符(默认值是/034) </p><pre>$ awk 'BEGIN{printf "%4s %4s %4s %4s %4s %4s %4s %4s %4s\n","FILENAME","ARGC","FNR","FS","NF","NR","OFS","ORS","RS";printf "---------------------------------------------\n"} {printf "%4s %4s %4s %4s %4s %4s %4s %4s %4s\n",FILENAME,ARGC,FNR,FS,NF,NR,OFS,ORS,RS}'  log.txt
FILENAME ARGC  FNR   FS   NF   NR  OFS  ORS   RS
---------------------------------------------
log.txt    2    1         5    1
log.txt    2    2         5    2
log.txt    2    3         3    3
log.txt    2    4         4    4
$ awk -F\' 'BEGIN{printf "%4s %4s %4s %4s %4s %4s %4s %4s %4s\n","FILENAME","ARGC","FNR","FS","NF","NR","OFS","ORS","RS";printf "---------------------------------------------\n"} {printf "%4s %4s %4s %4s %4s %4s %4s %4s %4s\n",FILENAME,ARGC,FNR,FS,NF,NR,OFS,ORS,RS}'  log.txt
FILENAME ARGC  FNR   FS   NF   NR  OFS  ORS   RS
---------------------------------------------
log.txt    2    1    '    1    1
log.txt    2    2    '    1    2
log.txt    2    3    '    2    3
log.txt    2    4    '    1    4
# 输出顺序号 NR, 匹配文本行号
$ awk '{print NR,FNR,$1,$2,$3}' log.txt
---------------------------------------------
1 1 2 this is
2 2 3 Are you
3 3 This's a test
4 4 10 There are
 
$  awk '{print $1,$2,$5}' OFS=" $ "  log.txt
---------------------------------------------
2 $ this $ test
3 $ Are $ awk
This's $ a $
10 $ There $
</pre> <h3>使用正则，字符串匹配</h3> <pre> 
$ awk '$2 ~ /th/ {print $2,$4}' log.txt
---------------------------------------------
this a
</pre> <p><strong>~ 表示模式开始。// 中是模式。</strong></p> <pre> 
$ awk '/re/ ' log.txt
---------------------------------------------
3 Are you like awk
10 There are orange,apple,mongo
</pre> <hr> <h3>忽略大小写</h3> <pre>$ awk 'BEGIN{IGNORECASE=1} /this/' log.txt
---------------------------------------------
2 this is a test
This's a test
</pre> <hr> <h3>模式取反</h3> <pre>$ awk '$2 !~ /th/ {print $2,$4}' log.txt
---------------------------------------------
Are like
a
There orange,apple,mongo
$ awk '!/th/ {print $2,$4}' log.txt
---------------------------------------------
Are like
a
There orange,apple,mongo
</pre> <hr> <h3>awk脚本</h3> <p>关于 awk 脚本，我们需要注意两个关键词 BEGIN 和 END。</p> <ul><li>BEGIN{ 这里面放的是执行前的语句 }</li><li>END {这里面放的是处理完所有的行后要执行的语句 }</li><li>{这里面放的是处理每一行时要执行的语句}</li></ul> <p>假设有这么一个文件（学生成绩表）：</p> <pre>$ cat score.txt
Marry   2143 78 84 77
Jack    2321 66 78 45
Tom     2122 48 77 71
Mike    2537 87 97 95
Bob     2415 40 57 62
</pre> <p>我们的 awk 脚本如下：</p> <pre>$ cat cal.awk
 
 
BEGIN {
    math = 0
    english = 0
    computer = 0
 
    printf "NAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL\n"
    printf "---------------------------------------------\n"
}
 
{
    math+=$3
    english+=$4
    computer+=$5
    printf "%-6s %-6s %4d %8d %8d %8d\n", $1, $2, $3,$4,$5, $3+$4+$5
}
 
END {
    printf "---------------------------------------------\n"
    printf "  TOTAL:%10d %8d %8d \n", math, english, computer
    printf "AVERAGE:%10.2f %8.2f %8.2f\n", math/NR, english/NR, computer/NR
}
</pre> <p>我们来看一下执行结果：</p> <pre>$ awk -f cal.awk score.txt
NAME    NO.   MATH  ENGLISH  COMPUTER   TOTAL
---------------------------------------------
Marry  2143     78       84       77      239
Jack   2321     66       78       45      189
Tom    2122     48       77       71      196
Mike   2537     87       97       95      279
Bob    2415     40       57       62      159
---------------------------------------------
  TOTAL:       319      393      350
AVERAGE:     63.80    78.60    70.00
</pre> <hr> <h3>另外一些实例</h3> <p>AWK 的 hello world 程序为：</p> <pre>BEGIN { print "Hello, world!" }
</pre> <p>计算文件大小</p> <pre>$ ls -l *.txt | awk '{sum+=$5} END {print sum}'
--------------------------------------------------
666581
</pre> <p>从文件中找出长度大于 80 的行：</p> <pre>awk 'length&gt;80' log.txt
</pre> <p>打印九九乘法表</p> <pre>seq 9 | sed 'H;g' | awk -v RS='' '{for(i=1;i&lt;=NF;i++)printf("%dx%d=%d%s", i, NR, i*NR, i==NR?"\n":"\t")}'
</pre> <h4>sed</h4> <p>Linux sed 命令是利用脚本来处理文本文件。</p> <p>sed 可依照脚本的指令来处理、编辑文本文件。</p> <p>Sed 主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。</p> <h3>语法</h3> <pre>sed [-hnV][-e&lt;script&gt;][-f&lt;script文件&gt;][文本文件]
</pre> <p><strong>参数说明</strong>：</p> <ul><li><code>-e&lt;script&gt;</code>或<code>--expression=&lt;script&gt;</code> 以选项中指定的script来处理输入的文本文件。</li><li>-f&lt;script文件&gt;或–file=&lt;script文件&gt; 以选项中指定的script文件来处理输入的文本文件。</li><li>-h或–help 显示帮助。</li><li>-n或–quiet或–silent 仅显示script处理后的结果。</li><li>-V或–version 显示版本信息。</li></ul> <p><strong>动作说明</strong>：</p> <ul><li>a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～</li><li>c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！</li><li>d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；</li><li>i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；</li><li>p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～</li><li>s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！</li></ul> <h3>实例</h3> <p>在testfile文件的第四行后添加一行，并将结果输出到标准输出，在命令行提示符下输入如下命令：</p> <pre>sed -e 4a\newLine testfile 
</pre> <p>首先查看testfile中的内容如下：</p> <pre>$ cat testfile  
HELLO LINUX!  
Linux is a free unix-type opterating system.  
This is a linux testfile!  
Linux test 
</pre> <p>使用sed命令后，输出结果如下：</p> <pre>$ sed -e 4a\newline testfile  
HELLO LINUX!  
Linux is a free unix-type opterating system.  
This is a linux testfile!  
Linux test  
newline 
</pre> <h3>以行为单位的新增/删除</h3> <p>将 /etc/passwd 的内容列出并且列印行号，同时，请将第 2~5 行删除！</p> <pre>[root@www ~] nl /etc/passwd | sed '2,5d'
1 root:x:0:0:root:/root:/bin/bash
6 sync:x:5:0:sync:/sbin:/bin/sync
7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
.....(后面省略).....
</pre> <p>sed 的动作为 ‘2,5d’ ，那个 d 就是删除！因为 2-5 行给他删除了，所以显示的数据就没有 2-5 行罗～ 另外，注意一下，原本应该是要下达 sed -e 才对，没有 -e 也行啦！同时也要注意的是， sed 后面接的动作，请务必以 ‘’ 两个单引号括住喔！</p> <p>只要删除第 2 行</p> <pre>nl /etc/passwd | sed '2d' 
</pre> <p>要删除第 3 到最后一行</p> <pre>nl /etc/passwd | sed '3,$d' 
</pre> <p>在第二行后(亦即是加在第三行)加上『drink tea?』字样！</p> <pre>[root@www ~] nl /etc/passwd | sed '2a drink tea'
1 root:x:0:0:root:/root:/bin/bash
2 bin:x:1:1:bin:/bin:/sbin/nologin
drink tea
3 daemon:x:2:2:daemon:/sbin:/sbin/nologin
.....(后面省略).....
</pre> <p>那如果是要在第二行前</p> <pre>nl /etc/passwd | sed '2i drink tea' 
</pre> <p>如果是要增加两行以上，在第二行后面加入两行字，例如 <strong>Drink tea or …</strong> 与 <strong>drink beer?</strong></p> <pre>[root@www ~] nl /etc/passwd | sed '2a Drink tea or ......\
&gt; drink beer ?'
1 root:x:0:0:root:/root:/bin/bash
2 bin:x:1:1:bin:/bin:/sbin/nologin
Drink tea or ......
drink beer ?
3 daemon:x:2:2:daemon:/sbin:/sbin/nologin
.....(后面省略).....
</pre> <p>每一行之间都必须要以反斜杠『 \ 』来进行新行的添加喔！所以，上面的例子中，我们可以发现在第一行的最后面就有 \ 存在。</p> <h3>以行为单位的替换与显示</h3> <p>将第2-5行的内容取代成为『No 2-5 number』呢？</p> <pre>[root@www ~] nl /etc/passwd | sed '2,5c No 2-5 number'
1 root:x:0:0:root:/root:/bin/bash
No 2-5 number
6 sync:x:5:0:sync:/sbin:/bin/sync
.....(后面省略).....
</pre> <p>透过这个方法我们就能够将数据整行取代了！</p> <p>仅列出 /etc/passwd 文件内的第 5-7 行</p> <pre>[root@www ~] nl /etc/passwd | sed -n '5,7p'
5 lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
6 sync:x:5:0:sync:/sbin:/bin/sync
7 shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
</pre> <p>可以透过这个 sed 的以行为单位的显示功能， 就能够将某一个文件内的某些行号选择出来显示。</p> <h3>数据的搜寻并显示</h3> <p>搜索 /etc/passwd有root关键字的行</p> <pre>nl /etc/passwd | sed '/root/p'
1  root:x:0:0:root:/root:/bin/bash
1  root:x:0:0:root:/root:/bin/bash
2  daemon:x:1:1:daemon:/usr/sbin:/bin/sh
3  bin:x:2:2:bin:/bin:/bin/sh
4  sys:x:3:3:sys:/dev:/bin/sh
5  sync:x:4:65534:sync:/bin:/bin/sync
....下面忽略 
</pre> <p>如果root找到，除了输出所有行，还会输出匹配行。</p> <p>使用-n的时候将只打印包含模板的行。</p> <pre>nl /etc/passwd | sed -n '/root/p'
1  root:x:0:0:root:/root:/bin/bash
</pre> <h3>数据的搜寻并删除</h3> <p>删除/etc/passwd所有包含root的行，其他行输出</p> <pre>nl /etc/passwd | sed  '/root/d'
2  daemon:x:1:1:daemon:/usr/sbin:/bin/sh
3  bin:x:2:2:bin:/bin:/bin/sh
....下面忽略
 
</pre> <h3>数据的搜寻并执行命令</h3> <p>搜索/etc/passwd,找到root对应的行，执行后面花括号中的一组命令，每个命令之间用分号分隔，这里把bash替换为blueshell，再输出这行：</p> <pre>nl /etc/passwd | sed -n '/root/{s/bash/blueshell/;p;q}'    
1  root:x:0:0:root:/root:/bin/blueshell
</pre> <p>最后的q是退出。</p> <h3>数据的搜寻并替换</h3> <p>除了整行的处理模式之外， sed 还可以用行为单位进行部分数据的搜寻并取代。基本上 sed 的搜寻与替代的与 vi 相当的类似！他有点像这样：</p> <pre>sed 's/要被取代的字串/新的字串/g'
</pre> <p>先观察原始信息，利用 /sbin/ifconfig 查询 IP</p> <pre>[root@www ~] /sbin/ifconfig eth0
eth0 Link encap:Ethernet HWaddr 00:90:CC:A6:34:84
inet addr:192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0
inet6 addr: fe80::290:ccff:fea6:3484/64 Scope:Link
UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1
.....(以下省略).....
</pre> <p>本机的ip是192.168.1.100。</p> <p>将 IP 前面的部分予以删除</p> <pre>[root@www ~] /sbin/ifconfig eth0 | grep 'inet addr' | sed 's/^.*addr://g'
192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0
</pre> <p>接下来则是删除后续的部分，亦即： 192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0</p> <p>将 IP 后面的部分予以删除</p> <pre>[root@www ~] /sbin/ifconfig eth0 | grep 'inet addr' | sed 's/^.*addr://g' | sed 's/Bcast.*$//g'
192.168.1.100
</pre> <h3>多点编辑</h3> <p>一条sed命令，删除/etc/passwd第三行到末尾的数据，并把bash替换为blueshell</p> <pre>nl /etc/passwd | sed -e '3,$d' -e 's/bash/blueshell/'
1  root:x:0:0:root:/root:/bin/blueshell
2  daemon:x:1:1:daemon:/usr/sbin:/bin/sh
</pre> <p>-e表示多点编辑，第一个编辑命令删除/etc/passwd第三行到末尾的数据，第二条命令搜索bash替换为blueshell。</p> <h3>直接修改文件内容(危险动作)</h3> <p>sed 可以直接修改文件的内容，不必使用管道命令或数据流重导向！ 不过，由於这个动作会直接修改到原始的文件，所以请你千万不要随便拿系统配置来测试！ 我们还是使用文件 regular_express.txt 文件来测试看看吧！</p> <p>regular_express.txt 文件内容如下：</p> <pre>[root@www ~] cat regular_express.txt 
runoob.
google.
taobao.
facebook.
zhihu-
weibo-
</pre> <p>利用 sed 将 regular_express.txt 内每一行结尾若为 . 则换成 !</p> <pre>[root@www ~] sed -i 's/\.$/\!/g' regular_express.txt
[root@www ~] cat regular_express.txt 
runoob!
google!
taobao!
facebook!
zhihu-
weibo-
</pre> <p>:q:q</p> <p>利用 sed 直接在 regular_express.txt 最后一行加入 <strong># This is a test</strong>:</p> <pre>[root@www ~] sed -i '$a # This is a test' regular_express.txt
[root@www ~] cat regular_express.txt 
runoob!
google!
taobao!
facebook!
zhihu-
weibo-
 
</pre> <p>由於 $ 代表的是最后一行，而 a 的动作是新增，因此该文件最后新增 <strong># This is a test</strong>！</p> <p>sed 的 <strong>-i</strong> 选项可以直接修改文件内容，这功能非常有帮助！举例来说，如果你有一个 100 万行的文件，你要在第 100 行加某些文字，此时使用 vim 可能会疯掉！因为文件太大了！那怎办？就利用 sed 啊！透过 sed 直接修改/取代的功能，你甚至不需要使用 vim 去修订！</p> <h3>追加行的说明：</h3> <pre>sed -e 4a\newline testfile
</pre> <p>a 动作是在匹配的行之后追加字符串，追加的字符串中可以包含换行符（实现追加多行的情况）。</p> <p>追加一行的话前后都不需要添加换行符 <strong>\n</strong>，只有追加多行时在行与行之间才需要添加换行符(最后一行最后也无需添加，添加的话会多出一个空行)。</p> <p>man sed 信息：</p> <pre>Append text, which has each embedded newline preceded by a backslash.
</pre> <p>例如：</p> <p>4 行之后添加一行：</p> <pre>sed -e '4 a newline' testfile
</pre> <p>4 行之后追加 2 行：</p> <pre>sed -e '4 a newline\nnewline2' testfile
</pre> <p>4 行之后追加 3 行(2 行文字和 1 行空行)</p> <pre>sed -e '4 a newline\nnewline2\n' testfile
</pre> <p>4 行之后追加 1 行空行：</p> <pre> 
sed -e '4 a \ ' testfile 实际上
</pre> <p>实际上是插入了一个含有一个空格的行，插入一个完全为空的空行没有找到方法（不过应该没有这个需求吧，都要插入行了插入空行干嘛呢？）</p> <p>添加空行：</p> <pre> 
sed '4 a \\'

 
sed '4 a \\n'
</pre> <h3>grep</h3> <p>Linux grep 命令用于查找文件里符合条件的字符串。</p> <p>grep 指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设 grep 指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 <strong>-</strong>，则 grep 指令会从标准输入设备读取数据。</p> <h3>语法</h3> <pre>grep [-abcEFGhHilLnqrsvVwxy][-A&lt;显示列数&gt;][-B&lt;显示列数&gt;][-C&lt;显示列数&gt;][-d&lt;进行动作&gt;][-e&lt;范本样式&gt;][-f&lt;范本文件&gt;][--help][范本样式][文件或目录...]
</pre> <p><strong>参数</strong>：</p> <ul><li><strong>-a 或 --text</strong> : 不要忽略二进制的数据。</li><li><strong>-A&lt;显示行数&gt; 或 --after-context=&lt;显示行数&gt;</strong> : 除了显示符合范本样式的那一列之外，并显示该行之后的内容。</li><li><strong>-b 或 --byte-offset</strong> : 在显示符合样式的那一行之前，标示出该行第一个字符的编号。</li><li><strong>-B&lt;显示行数&gt; 或 --before-context=&lt;显示行数&gt;</strong> : 除了显示符合样式的那一行之外，并显示该行之前的内容。</li><li><strong>-c 或 --count</strong> : 计算符合样式的列数。</li><li><strong>-C&lt;显示行数&gt; 或 --context=&lt;显示行数&gt;或-&lt;显示行数&gt;</strong> : 除了显示符合样式的那一行之外，并显示该行之前后的内容。</li><li><strong>-d &lt;动作&gt; 或 --directories=&lt;动作&gt;</strong> : 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。</li><li><strong>-e&lt;范本样式&gt; 或 --regexp=&lt;范本样式&gt;</strong> : 指定字符串做为查找文件内容的样式。</li><li><strong>-E 或 --extended-regexp</strong> : 将样式为延伸的正则表达式来使用。</li><li><strong>-f&lt;规则文件&gt; 或 --file=&lt;规则文件&gt;</strong> : 指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。</li><li><strong>-F 或 --fixed-regexp</strong> : 将样式视为固定字符串的列表。</li><li><strong>-G 或 --basic-regexp</strong> : 将样式视为普通的表示法来使用。</li><li><strong>-h 或 --no-filename</strong> : 在显示符合样式的那一行之前，不标示该行所属的文件名称。</li><li><strong>-H 或 --with-filename</strong> : 在显示符合样式的那一行之前，表示该行所属的文件名称。</li><li><strong>-i 或 --ignore-case</strong> : 忽略字符大小写的差别。</li><li><strong>-l 或 --file-with-matches</strong> : 列出文件内容符合指定的样式的文件名称。</li><li><strong>-L 或 --files-without-match</strong> : 列出文件内容不符合指定的样式的文件名称。</li><li><strong>-n 或 --line-number</strong> : 在显示符合样式的那一行之前，标示出该行的列数编号。</li><li><strong>-o 或 --only-matching</strong> : 只显示匹配PATTERN 部分。</li><li><strong>-q 或 --quiet或–silent</strong> : 不显示任何信息。</li><li><strong>-r 或 --recursive</strong> : 此参数的效果和指定"-d recurse"参数相同。</li><li><strong>-s 或 --no-messages</strong> : 不显示错误信息。</li><li><strong>-v 或 --revert-match</strong> : 显示不包含匹配文本的所有行。</li><li><strong>-V 或 --version</strong> : 显示版本信息。</li><li><strong>-w 或 --word-regexp</strong> : 只显示全字符合的列。</li><li><strong>-x --line-regexp</strong> : 只显示全列符合的列。</li><li><strong>-y</strong> : 此参数的效果和指定"-i"参数相同。</li></ul> <h3>实例</h3> <p>1、在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行。此时，可以使用如下命令：</p> <pre>grep test *file 
</pre> <p>结果如下所示：</p> <pre>$ grep test test*  
testfile1:This a Linux testfile!  
testfile_2:This is a linux testfile!  
testfile_2:Linux test  
</pre> <p>2、以递归的方式查找符合条件的文件。例如，查找指定目录/etc/acpi 及其子目录（如果存在子目录的话）下所有文件中包含字符串"update"的文件，并打印出该字符串所在行的内容，使用的命令为：</p> <pre>grep -r update /etc/acpi 
</pre> <p>输出结果如下：</p> <pre>$ grep -r update /etc/acpi  
 
/etc/acpi/ac.d/85-anacron.sh: 
Rather than  
/etc/acpi/resume.d/85-anacron.sh: 
IO.) Rather than  
/etc/acpi/events/thinkpad-cmos:action=/usr/sbin/thinkpad-keys--update 
</pre> <p>3、反向查找。前面各个例子是查找并打印出符合条件的行，通过"-v"参数可以打印出不符合条件行的内容。</p> <p>查找文件名中包含 test 的文件中不包含test 的行，此时，使用的命令为：</p> <pre>grep -v test *test*
</pre> <p>结果如下所示：</p> <pre>$ grep-v test*  
testfile1:helLinux!  
testfile1:Linis a free Unix-type operating system.  
testfile1:Lin  
testfile_1:HELLO LINUX!  
testfile_1:LINUX IS A FREE UNIX-TYPE OPTERATING SYSTEM.  
testfile_1:THIS IS A LINUX TESTFILE!  
testfile_2:HELLO LINUX!  
testfile_2:Linux is a free unix-type opterating system.  
</pre>